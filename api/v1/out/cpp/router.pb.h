// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_2eproto;
namespace trafficcontrol {
class CanaryRouting;
struct CanaryRoutingDefaultTypeInternal;
extern CanaryRoutingDefaultTypeInternal _CanaryRouting_default_instance_;
class DegradeConfig;
struct DegradeConfigDefaultTypeInternal;
extern DegradeConfigDefaultTypeInternal _DegradeConfig_default_instance_;
class Destination;
struct DestinationDefaultTypeInternal;
extern DestinationDefaultTypeInternal _Destination_default_instance_;
class Destination_MetadataEntry_DoNotUse;
struct Destination_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Destination_MetadataEntry_DoNotUseDefaultTypeInternal _Destination_MetadataEntry_DoNotUse_default_instance_;
class Locality;
struct LocalityDefaultTypeInternal;
extern LocalityDefaultTypeInternal _Locality_default_instance_;
class LocalityRouting;
struct LocalityRoutingDefaultTypeInternal;
extern LocalityRoutingDefaultTypeInternal _LocalityRouting_default_instance_;
class MatchString;
struct MatchStringDefaultTypeInternal;
extern MatchStringDefaultTypeInternal _MatchString_default_instance_;
class MetadataRouting;
struct MetadataRoutingDefaultTypeInternal;
extern MetadataRoutingDefaultTypeInternal _MetadataRouting_default_instance_;
class Route;
struct RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class RouteConfiguration;
struct RouteConfigurationDefaultTypeInternal;
extern RouteConfigurationDefaultTypeInternal _RouteConfiguration_default_instance_;
class Router;
struct RouterDefaultTypeInternal;
extern RouterDefaultTypeInternal _Router_default_instance_;
class RuleRouting;
struct RuleRoutingDefaultTypeInternal;
extern RuleRoutingDefaultTypeInternal _RuleRouting_default_instance_;
class SetRouting;
struct SetRoutingDefaultTypeInternal;
extern SetRoutingDefaultTypeInternal _SetRouting_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class Source_MetadataEntry_DoNotUse;
struct Source_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Source_MetadataEntry_DoNotUseDefaultTypeInternal _Source_MetadataEntry_DoNotUse_default_instance_;
}  // namespace trafficcontrol
PROTOBUF_NAMESPACE_OPEN
template<> ::trafficcontrol::CanaryRouting* Arena::CreateMaybeMessage<::trafficcontrol::CanaryRouting>(Arena*);
template<> ::trafficcontrol::DegradeConfig* Arena::CreateMaybeMessage<::trafficcontrol::DegradeConfig>(Arena*);
template<> ::trafficcontrol::Destination* Arena::CreateMaybeMessage<::trafficcontrol::Destination>(Arena*);
template<> ::trafficcontrol::Destination_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::trafficcontrol::Destination_MetadataEntry_DoNotUse>(Arena*);
template<> ::trafficcontrol::Locality* Arena::CreateMaybeMessage<::trafficcontrol::Locality>(Arena*);
template<> ::trafficcontrol::LocalityRouting* Arena::CreateMaybeMessage<::trafficcontrol::LocalityRouting>(Arena*);
template<> ::trafficcontrol::MatchString* Arena::CreateMaybeMessage<::trafficcontrol::MatchString>(Arena*);
template<> ::trafficcontrol::MetadataRouting* Arena::CreateMaybeMessage<::trafficcontrol::MetadataRouting>(Arena*);
template<> ::trafficcontrol::Route* Arena::CreateMaybeMessage<::trafficcontrol::Route>(Arena*);
template<> ::trafficcontrol::RouteConfiguration* Arena::CreateMaybeMessage<::trafficcontrol::RouteConfiguration>(Arena*);
template<> ::trafficcontrol::Router* Arena::CreateMaybeMessage<::trafficcontrol::Router>(Arena*);
template<> ::trafficcontrol::RuleRouting* Arena::CreateMaybeMessage<::trafficcontrol::RuleRouting>(Arena*);
template<> ::trafficcontrol::SetRouting* Arena::CreateMaybeMessage<::trafficcontrol::SetRouting>(Arena*);
template<> ::trafficcontrol::Source* Arena::CreateMaybeMessage<::trafficcontrol::Source>(Arena*);
template<> ::trafficcontrol::Source_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::trafficcontrol::Source_MetadataEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trafficcontrol {

enum MatchString_MatchStringType : int {
  MatchString_MatchStringType_EXACT = 0,
  MatchString_MatchStringType_REGEX = 1,
  MatchString_MatchStringType_NOT_EQUALS = 2,
  MatchString_MatchStringType_INCLUDE = 3,
  MatchString_MatchStringType_NOT_INCLUDE = 4,
  MatchString_MatchStringType_MatchString_MatchStringType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchString_MatchStringType_MatchString_MatchStringType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchString_MatchStringType_IsValid(int value);
constexpr MatchString_MatchStringType MatchString_MatchStringType_MatchStringType_MIN = MatchString_MatchStringType_EXACT;
constexpr MatchString_MatchStringType MatchString_MatchStringType_MatchStringType_MAX = MatchString_MatchStringType_NOT_INCLUDE;
constexpr int MatchString_MatchStringType_MatchStringType_ARRAYSIZE = MatchString_MatchStringType_MatchStringType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchString_MatchStringType_descriptor();
template<typename T>
inline const std::string& MatchString_MatchStringType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchString_MatchStringType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchString_MatchStringType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchString_MatchStringType_descriptor(), enum_t_value);
}
inline bool MatchString_MatchStringType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchString_MatchStringType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchString_MatchStringType>(
    MatchString_MatchStringType_descriptor(), name, value);
}
enum MatchString_ValueType : int {
  MatchString_ValueType_TEXT = 0,
  MatchString_ValueType_PARAMETER = 1,
  MatchString_ValueType_VARIABLE = 2,
  MatchString_ValueType_MatchString_ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchString_ValueType_MatchString_ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchString_ValueType_IsValid(int value);
constexpr MatchString_ValueType MatchString_ValueType_ValueType_MIN = MatchString_ValueType_TEXT;
constexpr MatchString_ValueType MatchString_ValueType_ValueType_MAX = MatchString_ValueType_VARIABLE;
constexpr int MatchString_ValueType_ValueType_ARRAYSIZE = MatchString_ValueType_ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchString_ValueType_descriptor();
template<typename T>
inline const std::string& MatchString_ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchString_ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchString_ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchString_ValueType_descriptor(), enum_t_value);
}
inline bool MatchString_ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchString_ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchString_ValueType>(
    MatchString_ValueType_descriptor(), name, value);
}
enum LocalityRouting_LocalityLevel : int {
  LocalityRouting_LocalityLevel_CAMPUS = 0,
  LocalityRouting_LocalityLevel_ZONE = 1,
  LocalityRouting_LocalityLevel_REGION = 2,
  LocalityRouting_LocalityLevel_ALL = 3,
  LocalityRouting_LocalityLevel_LocalityRouting_LocalityLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LocalityRouting_LocalityLevel_LocalityRouting_LocalityLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LocalityRouting_LocalityLevel_IsValid(int value);
constexpr LocalityRouting_LocalityLevel LocalityRouting_LocalityLevel_LocalityLevel_MIN = LocalityRouting_LocalityLevel_CAMPUS;
constexpr LocalityRouting_LocalityLevel LocalityRouting_LocalityLevel_LocalityLevel_MAX = LocalityRouting_LocalityLevel_ALL;
constexpr int LocalityRouting_LocalityLevel_LocalityLevel_ARRAYSIZE = LocalityRouting_LocalityLevel_LocalityLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocalityRouting_LocalityLevel_descriptor();
template<typename T>
inline const std::string& LocalityRouting_LocalityLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocalityRouting_LocalityLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocalityRouting_LocalityLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocalityRouting_LocalityLevel_descriptor(), enum_t_value);
}
inline bool LocalityRouting_LocalityLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocalityRouting_LocalityLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocalityRouting_LocalityLevel>(
    LocalityRouting_LocalityLevel_descriptor(), name, value);
}
enum MetadataRouting_DegradeLevel : int {
  MetadataRouting_DegradeLevel_ALL = 0,
  MetadataRouting_DegradeLevel_OTHERS = 1,
  MetadataRouting_DegradeLevel_MetadataRouting_DegradeLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetadataRouting_DegradeLevel_MetadataRouting_DegradeLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetadataRouting_DegradeLevel_IsValid(int value);
constexpr MetadataRouting_DegradeLevel MetadataRouting_DegradeLevel_DegradeLevel_MIN = MetadataRouting_DegradeLevel_ALL;
constexpr MetadataRouting_DegradeLevel MetadataRouting_DegradeLevel_DegradeLevel_MAX = MetadataRouting_DegradeLevel_OTHERS;
constexpr int MetadataRouting_DegradeLevel_DegradeLevel_ARRAYSIZE = MetadataRouting_DegradeLevel_DegradeLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetadataRouting_DegradeLevel_descriptor();
template<typename T>
inline const std::string& MetadataRouting_DegradeLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetadataRouting_DegradeLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetadataRouting_DegradeLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetadataRouting_DegradeLevel_descriptor(), enum_t_value);
}
inline bool MetadataRouting_DegradeLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetadataRouting_DegradeLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetadataRouting_DegradeLevel>(
    MetadataRouting_DegradeLevel_descriptor(), name, value);
}
enum CanaryRouting_DegradeLevel : int {
  CanaryRouting_DegradeLevel_ALL = 0,
  CanaryRouting_DegradeLevel_OTHERS = 1,
  CanaryRouting_DegradeLevel_OTHERS_WITHOUT_CANARY = 2,
  CanaryRouting_DegradeLevel_CanaryRouting_DegradeLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CanaryRouting_DegradeLevel_CanaryRouting_DegradeLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CanaryRouting_DegradeLevel_IsValid(int value);
constexpr CanaryRouting_DegradeLevel CanaryRouting_DegradeLevel_DegradeLevel_MIN = CanaryRouting_DegradeLevel_ALL;
constexpr CanaryRouting_DegradeLevel CanaryRouting_DegradeLevel_DegradeLevel_MAX = CanaryRouting_DegradeLevel_OTHERS_WITHOUT_CANARY;
constexpr int CanaryRouting_DegradeLevel_DegradeLevel_ARRAYSIZE = CanaryRouting_DegradeLevel_DegradeLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CanaryRouting_DegradeLevel_descriptor();
template<typename T>
inline const std::string& CanaryRouting_DegradeLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CanaryRouting_DegradeLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CanaryRouting_DegradeLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CanaryRouting_DegradeLevel_descriptor(), enum_t_value);
}
inline bool CanaryRouting_DegradeLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CanaryRouting_DegradeLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CanaryRouting_DegradeLevel>(
    CanaryRouting_DegradeLevel_descriptor(), name, value);
}
enum RouterType : int {
  RuleRouter = 0,
  MetadataRouter = 1,
  LocalityRouter = 2,
  CanaryRouter = 3,
  SetRouter = 4,
  RouterType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RouterType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RouterType_IsValid(int value);
constexpr RouterType RouterType_MIN = RuleRouter;
constexpr RouterType RouterType_MAX = SetRouter;
constexpr int RouterType_ARRAYSIZE = RouterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RouterType_descriptor();
template<typename T>
inline const std::string& RouterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RouterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RouterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RouterType_descriptor(), enum_t_value);
}
inline bool RouterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RouterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RouterType>(
    RouterType_descriptor(), name, value);
}
// ===================================================================

class RouteConfiguration final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.RouteConfiguration) */ {
 public:
  inline RouteConfiguration() : RouteConfiguration(nullptr) {}
  ~RouteConfiguration() override;
  explicit PROTOBUF_CONSTEXPR RouteConfiguration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RouteConfiguration(const RouteConfiguration& from);
  RouteConfiguration(RouteConfiguration&& from) noexcept
    : RouteConfiguration() {
    *this = ::std::move(from);
  }

  inline RouteConfiguration& operator=(const RouteConfiguration& from) {
    CopyFrom(from);
    return *this;
  }
  inline RouteConfiguration& operator=(RouteConfiguration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RouteConfiguration& default_instance() {
    return *internal_default_instance();
  }
  static inline const RouteConfiguration* internal_default_instance() {
    return reinterpret_cast<const RouteConfiguration*>(
               &_RouteConfiguration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RouteConfiguration& a, RouteConfiguration& b) {
    a.Swap(&b);
  }
  inline void Swap(RouteConfiguration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RouteConfiguration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RouteConfiguration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RouteConfiguration>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RouteConfiguration& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RouteConfiguration& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteConfiguration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.RouteConfiguration";
  }
  protected:
  explicit RouteConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutersFieldNumber = 1,
  };
  // repeated .trafficcontrol.Router routers = 1;
  int routers_size() const;
  private:
  int _internal_routers_size() const;
  public:
  void clear_routers();
  ::trafficcontrol::Router* mutable_routers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >*
      mutable_routers();
  private:
  const ::trafficcontrol::Router& _internal_routers(int index) const;
  ::trafficcontrol::Router* _internal_add_routers();
  public:
  const ::trafficcontrol::Router& routers(int index) const;
  ::trafficcontrol::Router* add_routers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >&
      routers() const;

  // @@protoc_insertion_point(class_scope:trafficcontrol.RouteConfiguration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router > routers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Router final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Router) */ {
 public:
  inline Router() : Router(nullptr) {}
  ~Router() override;
  explicit PROTOBUF_CONSTEXPR Router(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Router(const Router& from);
  Router(Router&& from) noexcept
    : Router() {
    *this = ::std::move(from);
  }

  inline Router& operator=(const Router& from) {
    CopyFrom(from);
    return *this;
  }
  inline Router& operator=(Router&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Router& default_instance() {
    return *internal_default_instance();
  }
  static inline const Router* internal_default_instance() {
    return reinterpret_cast<const Router*>(
               &_Router_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Router& a, Router& b) {
    a.Swap(&b);
  }
  inline void Swap(Router* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Router* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Router* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Router>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Router& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Router& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Router* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Router";
  }
  protected:
  explicit Router(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoutingFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // .google.protobuf.Any routing = 2;
  bool has_routing() const;
  private:
  bool _internal_has_routing() const;
  public:
  void clear_routing();
  const ::PROTOBUF_NAMESPACE_ID::Any& routing() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_routing();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_routing();
  void set_allocated_routing(::PROTOBUF_NAMESPACE_ID::Any* routing);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_routing() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_routing();
  public:
  void unsafe_arena_set_allocated_routing(
      ::PROTOBUF_NAMESPACE_ID::Any* routing);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_routing();

  // .trafficcontrol.RouterType type = 1;
  void clear_type();
  ::trafficcontrol::RouterType type() const;
  void set_type(::trafficcontrol::RouterType value);
  private:
  ::trafficcontrol::RouterType _internal_type() const;
  void _internal_set_type(::trafficcontrol::RouterType value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.Router)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::Any* routing_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class MatchString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.MatchString) */ {
 public:
  inline MatchString() : MatchString(nullptr) {}
  ~MatchString() override;
  explicit PROTOBUF_CONSTEXPR MatchString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchString(const MatchString& from);
  MatchString(MatchString&& from) noexcept
    : MatchString() {
    *this = ::std::move(from);
  }

  inline MatchString& operator=(const MatchString& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchString& operator=(MatchString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchString& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchString* internal_default_instance() {
    return reinterpret_cast<const MatchString*>(
               &_MatchString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MatchString& a, MatchString& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchString& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.MatchString";
  }
  protected:
  explicit MatchString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatchString_MatchStringType MatchStringType;
  static constexpr MatchStringType EXACT =
    MatchString_MatchStringType_EXACT;
  static constexpr MatchStringType REGEX =
    MatchString_MatchStringType_REGEX;
  static constexpr MatchStringType NOT_EQUALS =
    MatchString_MatchStringType_NOT_EQUALS;
  static constexpr MatchStringType INCLUDE =
    MatchString_MatchStringType_INCLUDE;
  static constexpr MatchStringType NOT_INCLUDE =
    MatchString_MatchStringType_NOT_INCLUDE;
  static inline bool MatchStringType_IsValid(int value) {
    return MatchString_MatchStringType_IsValid(value);
  }
  static constexpr MatchStringType MatchStringType_MIN =
    MatchString_MatchStringType_MatchStringType_MIN;
  static constexpr MatchStringType MatchStringType_MAX =
    MatchString_MatchStringType_MatchStringType_MAX;
  static constexpr int MatchStringType_ARRAYSIZE =
    MatchString_MatchStringType_MatchStringType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchStringType_descriptor() {
    return MatchString_MatchStringType_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchStringType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchStringType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchStringType_Name.");
    return MatchString_MatchStringType_Name(enum_t_value);
  }
  static inline bool MatchStringType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchStringType* value) {
    return MatchString_MatchStringType_Parse(name, value);
  }

  typedef MatchString_ValueType ValueType;
  static constexpr ValueType TEXT =
    MatchString_ValueType_TEXT;
  static constexpr ValueType PARAMETER =
    MatchString_ValueType_PARAMETER;
  static constexpr ValueType VARIABLE =
    MatchString_ValueType_VARIABLE;
  static inline bool ValueType_IsValid(int value) {
    return MatchString_ValueType_IsValid(value);
  }
  static constexpr ValueType ValueType_MIN =
    MatchString_ValueType_ValueType_MIN;
  static constexpr ValueType ValueType_MAX =
    MatchString_ValueType_ValueType_MAX;
  static constexpr int ValueType_ARRAYSIZE =
    MatchString_ValueType_ValueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ValueType_descriptor() {
    return MatchString_ValueType_descriptor();
  }
  template<typename T>
  static inline const std::string& ValueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValueType_Name.");
    return MatchString_ValueType_Name(enum_t_value);
  }
  static inline bool ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValueType* value) {
    return MatchString_ValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
    kValueTypeFieldNumber = 3,
  };
  // .google.protobuf.StringValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_value();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::StringValue* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::StringValue* value);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_value();

  // .trafficcontrol.MatchString.MatchStringType type = 1;
  void clear_type();
  ::trafficcontrol::MatchString_MatchStringType type() const;
  void set_type(::trafficcontrol::MatchString_MatchStringType value);
  private:
  ::trafficcontrol::MatchString_MatchStringType _internal_type() const;
  void _internal_set_type(::trafficcontrol::MatchString_MatchStringType value);
  public:

  // .trafficcontrol.MatchString.ValueType value_type = 3;
  void clear_value_type();
  ::trafficcontrol::MatchString_ValueType value_type() const;
  void set_value_type(::trafficcontrol::MatchString_ValueType value);
  private:
  ::trafficcontrol::MatchString_ValueType _internal_value_type() const;
  void _internal_set_value_type(::trafficcontrol::MatchString_ValueType value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.MatchString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* value_;
  int type_;
  int value_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Locality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Locality) */ {
 public:
  inline Locality() : Locality(nullptr) {}
  ~Locality() override;
  explicit PROTOBUF_CONSTEXPR Locality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Locality(const Locality& from);
  Locality(Locality&& from) noexcept
    : Locality() {
    *this = ::std::move(from);
  }

  inline Locality& operator=(const Locality& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locality& operator=(Locality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locality& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locality* internal_default_instance() {
    return reinterpret_cast<const Locality*>(
               &_Locality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Locality& a, Locality& b) {
    a.Swap(&b);
  }
  inline void Swap(Locality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Locality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Locality& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Locality";
  }
  protected:
  explicit Locality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kZoneFieldNumber = 2,
    kCampusFieldNumber = 3,
  };
  // .trafficcontrol.MatchString region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::trafficcontrol::MatchString& region() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_region();
  ::trafficcontrol::MatchString* mutable_region();
  void set_allocated_region(::trafficcontrol::MatchString* region);
  private:
  const ::trafficcontrol::MatchString& _internal_region() const;
  ::trafficcontrol::MatchString* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::trafficcontrol::MatchString* region);
  ::trafficcontrol::MatchString* unsafe_arena_release_region();

  // .trafficcontrol.MatchString zone = 2;
  bool has_zone() const;
  private:
  bool _internal_has_zone() const;
  public:
  void clear_zone();
  const ::trafficcontrol::MatchString& zone() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_zone();
  ::trafficcontrol::MatchString* mutable_zone();
  void set_allocated_zone(::trafficcontrol::MatchString* zone);
  private:
  const ::trafficcontrol::MatchString& _internal_zone() const;
  ::trafficcontrol::MatchString* _internal_mutable_zone();
  public:
  void unsafe_arena_set_allocated_zone(
      ::trafficcontrol::MatchString* zone);
  ::trafficcontrol::MatchString* unsafe_arena_release_zone();

  // .trafficcontrol.MatchString campus = 3;
  bool has_campus() const;
  private:
  bool _internal_has_campus() const;
  public:
  void clear_campus();
  const ::trafficcontrol::MatchString& campus() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_campus();
  ::trafficcontrol::MatchString* mutable_campus();
  void set_allocated_campus(::trafficcontrol::MatchString* campus);
  private:
  const ::trafficcontrol::MatchString& _internal_campus() const;
  ::trafficcontrol::MatchString* _internal_mutable_campus();
  public:
  void unsafe_arena_set_allocated_campus(
      ::trafficcontrol::MatchString* campus);
  ::trafficcontrol::MatchString* unsafe_arena_release_campus();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Locality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trafficcontrol::MatchString* region_;
  ::trafficcontrol::MatchString* zone_;
  ::trafficcontrol::MatchString* campus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class DegradeConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.DegradeConfig) */ {
 public:
  inline DegradeConfig() : DegradeConfig(nullptr) {}
  ~DegradeConfig() override;
  explicit PROTOBUF_CONSTEXPR DegradeConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DegradeConfig(const DegradeConfig& from);
  DegradeConfig(DegradeConfig&& from) noexcept
    : DegradeConfig() {
    *this = ::std::move(from);
  }

  inline DegradeConfig& operator=(const DegradeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DegradeConfig& operator=(DegradeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DegradeConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DegradeConfig* internal_default_instance() {
    return reinterpret_cast<const DegradeConfig*>(
               &_DegradeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DegradeConfig& a, DegradeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DegradeConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DegradeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DegradeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DegradeConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DegradeConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DegradeConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DegradeConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.DegradeConfig";
  }
  protected:
  explicit DegradeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
    kTotalCountFieldNumber = 2,
    kHealthyCountFieldNumber = 3,
    kHealthyPercentFieldNumber = 4,
  };
  // .google.protobuf.BoolValue enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& enable() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_enable();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_enable();
  void set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_enable() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_enable();
  public:
  void unsafe_arena_set_allocated_enable(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_enable();

  // .google.protobuf.UInt32Value total_count = 2;
  bool has_total_count() const;
  private:
  bool _internal_has_total_count() const;
  public:
  void clear_total_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& total_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_total_count();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_total_count();
  void set_allocated_total_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_total_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_total_count();
  public:
  void unsafe_arena_set_allocated_total_count(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_total_count();

  // .google.protobuf.UInt32Value healthy_count = 3;
  bool has_healthy_count() const;
  private:
  bool _internal_has_healthy_count() const;
  public:
  void clear_healthy_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& healthy_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_healthy_count();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_healthy_count();
  void set_allocated_healthy_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_healthy_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_healthy_count();
  public:
  void unsafe_arena_set_allocated_healthy_count(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_healthy_count();

  // .google.protobuf.UInt32Value healthy_percent = 4;
  bool has_healthy_percent() const;
  private:
  bool _internal_has_healthy_percent() const;
  public:
  void clear_healthy_percent();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& healthy_percent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_healthy_percent();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_healthy_percent();
  void set_allocated_healthy_percent(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_healthy_percent() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_healthy_percent();
  public:
  void unsafe_arena_set_allocated_healthy_percent(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_healthy_percent();

  // @@protoc_insertion_point(class_scope:trafficcontrol.DegradeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class RuleRouting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.RuleRouting) */ {
 public:
  inline RuleRouting() : RuleRouting(nullptr) {}
  ~RuleRouting() override;
  explicit PROTOBUF_CONSTEXPR RuleRouting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleRouting(const RuleRouting& from);
  RuleRouting(RuleRouting&& from) noexcept
    : RuleRouting() {
    *this = ::std::move(from);
  }

  inline RuleRouting& operator=(const RuleRouting& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleRouting& operator=(RuleRouting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleRouting& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuleRouting* internal_default_instance() {
    return reinterpret_cast<const RuleRouting*>(
               &_RuleRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RuleRouting& a, RuleRouting& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleRouting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleRouting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleRouting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleRouting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleRouting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuleRouting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleRouting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.RuleRouting";
  }
  protected:
  explicit RuleRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInboundsFieldNumber = 3,
    kOutboundsFieldNumber = 4,
    kNamespaceFieldNumber = 1,
    kServiceFieldNumber = 2,
    kDegradeFieldNumber = 5,
  };
  // repeated .trafficcontrol.Route inbounds = 3;
  int inbounds_size() const;
  private:
  int _internal_inbounds_size() const;
  public:
  void clear_inbounds();
  ::trafficcontrol::Route* mutable_inbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_inbounds();
  private:
  const ::trafficcontrol::Route& _internal_inbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_inbounds();
  public:
  const ::trafficcontrol::Route& inbounds(int index) const;
  ::trafficcontrol::Route* add_inbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      inbounds() const;

  // repeated .trafficcontrol.Route outbounds = 4;
  int outbounds_size() const;
  private:
  int _internal_outbounds_size() const;
  public:
  void clear_outbounds();
  ::trafficcontrol::Route* mutable_outbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_outbounds();
  private:
  const ::trafficcontrol::Route& _internal_outbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_outbounds();
  public:
  const ::trafficcontrol::Route& outbounds(int index) const;
  ::trafficcontrol::Route* add_outbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      outbounds() const;

  // .google.protobuf.StringValue namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .google.protobuf.StringValue service = 2;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .trafficcontrol.DegradeConfig degrade = 5;
  bool has_degrade() const;
  private:
  bool _internal_has_degrade() const;
  public:
  void clear_degrade();
  const ::trafficcontrol::DegradeConfig& degrade() const;
  PROTOBUF_NODISCARD ::trafficcontrol::DegradeConfig* release_degrade();
  ::trafficcontrol::DegradeConfig* mutable_degrade();
  void set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade);
  private:
  const ::trafficcontrol::DegradeConfig& _internal_degrade() const;
  ::trafficcontrol::DegradeConfig* _internal_mutable_degrade();
  public:
  void unsafe_arena_set_allocated_degrade(
      ::trafficcontrol::DegradeConfig* degrade);
  ::trafficcontrol::DegradeConfig* unsafe_arena_release_degrade();

  // @@protoc_insertion_point(class_scope:trafficcontrol.RuleRouting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > inbounds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > outbounds_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::trafficcontrol::DegradeConfig* degrade_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Route final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Route) */ {
 public:
  inline Route() : Route(nullptr) {}
  ~Route() override;
  explicit PROTOBUF_CONSTEXPR Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Route(const Route& from);
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Route& operator=(Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }
  inline void Swap(Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Route& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Route& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Route";
  }
  protected:
  explicit Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 1,
    kDestinationsFieldNumber = 2,
  };
  // repeated .trafficcontrol.Source sources = 1;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::trafficcontrol::Source* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >*
      mutable_sources();
  private:
  const ::trafficcontrol::Source& _internal_sources(int index) const;
  ::trafficcontrol::Source* _internal_add_sources();
  public:
  const ::trafficcontrol::Source& sources(int index) const;
  ::trafficcontrol::Source* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >&
      sources() const;

  // repeated .trafficcontrol.Destination destinations = 2;
  int destinations_size() const;
  private:
  int _internal_destinations_size() const;
  public:
  void clear_destinations();
  ::trafficcontrol::Destination* mutable_destinations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >*
      mutable_destinations();
  private:
  const ::trafficcontrol::Destination& _internal_destinations(int index) const;
  ::trafficcontrol::Destination* _internal_add_destinations();
  public:
  const ::trafficcontrol::Destination& destinations(int index) const;
  ::trafficcontrol::Destination* add_destinations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >&
      destinations() const;

  // @@protoc_insertion_point(class_scope:trafficcontrol.Route)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination > destinations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Source_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Source_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Source_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Source_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Source_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Source_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Source_MetadataEntry_DoNotUse& other);
  static const Source_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Source_MetadataEntry_DoNotUse*>(&_Source_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "trafficcontrol.Source.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_2eproto;
};

// -------------------------------------------------------------------

class Source final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  explicit PROTOBUF_CONSTEXPR Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Source& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kServiceFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kLocalityFieldNumber = 4,
  };
  // map<string, .trafficcontrol.MatchString> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      mutable_metadata();

  // .google.protobuf.StringValue service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .google.protobuf.StringValue namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .trafficcontrol.Locality locality = 4;
  bool has_locality() const;
  private:
  bool _internal_has_locality() const;
  public:
  void clear_locality();
  const ::trafficcontrol::Locality& locality() const;
  PROTOBUF_NODISCARD ::trafficcontrol::Locality* release_locality();
  ::trafficcontrol::Locality* mutable_locality();
  void set_allocated_locality(::trafficcontrol::Locality* locality);
  private:
  const ::trafficcontrol::Locality& _internal_locality() const;
  ::trafficcontrol::Locality* _internal_mutable_locality();
  public:
  void unsafe_arena_set_allocated_locality(
      ::trafficcontrol::Locality* locality);
  ::trafficcontrol::Locality* unsafe_arena_release_locality();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Source_MetadataEntry_DoNotUse,
      std::string, ::trafficcontrol::MatchString,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metadata_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::trafficcontrol::Locality* locality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Destination_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Destination_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Destination_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Destination_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Destination_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Destination_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Destination_MetadataEntry_DoNotUse& other);
  static const Destination_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Destination_MetadataEntry_DoNotUse*>(&_Destination_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "trafficcontrol.Destination.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_2eproto;
};

// -------------------------------------------------------------------

class Destination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Destination) */ {
 public:
  inline Destination() : Destination(nullptr) {}
  ~Destination() override;
  explicit PROTOBUF_CONSTEXPR Destination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Destination(const Destination& from);
  Destination(Destination&& from) noexcept
    : Destination() {
    *this = ::std::move(from);
  }

  inline Destination& operator=(const Destination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Destination& operator=(Destination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Destination& default_instance() {
    return *internal_default_instance();
  }
  static inline const Destination* internal_default_instance() {
    return reinterpret_cast<const Destination*>(
               &_Destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Destination& a, Destination& b) {
    a.Swap(&b);
  }
  inline void Swap(Destination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Destination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Destination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Destination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Destination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Destination& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Destination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Destination";
  }
  protected:
  explicit Destination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kServiceFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kPriorityFieldNumber = 4,
    kWeightFieldNumber = 5,
    kTransferFieldNumber = 6,
    kIsolateFieldNumber = 7,
    kLocalityFieldNumber = 8,
  };
  // map<string, .trafficcontrol.MatchString> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      mutable_metadata();

  // .google.protobuf.StringValue service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .google.protobuf.StringValue namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .google.protobuf.UInt32Value priority = 4;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& priority() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_priority();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_priority();
  void set_allocated_priority(::PROTOBUF_NAMESPACE_ID::UInt32Value* priority);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_priority() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_priority();
  public:
  void unsafe_arena_set_allocated_priority(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_priority();

  // .google.protobuf.UInt32Value weight = 5;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& weight() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_weight();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_weight();
  void set_allocated_weight(::PROTOBUF_NAMESPACE_ID::UInt32Value* weight);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_weight() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_weight();
  public:
  void unsafe_arena_set_allocated_weight(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_weight();

  // .google.protobuf.StringValue transfer = 6;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& transfer() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_transfer();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_transfer();
  void set_allocated_transfer(::PROTOBUF_NAMESPACE_ID::StringValue* transfer);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_transfer() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::PROTOBUF_NAMESPACE_ID::StringValue* transfer);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_transfer();

  // .google.protobuf.BoolValue isolate = 7;
  bool has_isolate() const;
  private:
  bool _internal_has_isolate() const;
  public:
  void clear_isolate();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& isolate() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_isolate();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_isolate();
  void set_allocated_isolate(::PROTOBUF_NAMESPACE_ID::BoolValue* isolate);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_isolate() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_isolate();
  public:
  void unsafe_arena_set_allocated_isolate(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_isolate();

  // .trafficcontrol.Locality locality = 8;
  bool has_locality() const;
  private:
  bool _internal_has_locality() const;
  public:
  void clear_locality();
  const ::trafficcontrol::Locality& locality() const;
  PROTOBUF_NODISCARD ::trafficcontrol::Locality* release_locality();
  ::trafficcontrol::Locality* mutable_locality();
  void set_allocated_locality(::trafficcontrol::Locality* locality);
  private:
  const ::trafficcontrol::Locality& _internal_locality() const;
  ::trafficcontrol::Locality* _internal_mutable_locality();
  public:
  void unsafe_arena_set_allocated_locality(
      ::trafficcontrol::Locality* locality);
  ::trafficcontrol::Locality* unsafe_arena_release_locality();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Destination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Destination_MetadataEntry_DoNotUse,
      std::string, ::trafficcontrol::MatchString,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metadata_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* transfer_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate_;
  ::trafficcontrol::Locality* locality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class LocalityRouting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.LocalityRouting) */ {
 public:
  inline LocalityRouting() : LocalityRouting(nullptr) {}
  ~LocalityRouting() override;
  explicit PROTOBUF_CONSTEXPR LocalityRouting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalityRouting(const LocalityRouting& from);
  LocalityRouting(LocalityRouting&& from) noexcept
    : LocalityRouting() {
    *this = ::std::move(from);
  }

  inline LocalityRouting& operator=(const LocalityRouting& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalityRouting& operator=(LocalityRouting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalityRouting& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalityRouting* internal_default_instance() {
    return reinterpret_cast<const LocalityRouting*>(
               &_LocalityRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LocalityRouting& a, LocalityRouting& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalityRouting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalityRouting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalityRouting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalityRouting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalityRouting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalityRouting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalityRouting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.LocalityRouting";
  }
  protected:
  explicit LocalityRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocalityRouting_LocalityLevel LocalityLevel;
  static constexpr LocalityLevel CAMPUS =
    LocalityRouting_LocalityLevel_CAMPUS;
  static constexpr LocalityLevel ZONE =
    LocalityRouting_LocalityLevel_ZONE;
  static constexpr LocalityLevel REGION =
    LocalityRouting_LocalityLevel_REGION;
  static constexpr LocalityLevel ALL =
    LocalityRouting_LocalityLevel_ALL;
  static inline bool LocalityLevel_IsValid(int value) {
    return LocalityRouting_LocalityLevel_IsValid(value);
  }
  static constexpr LocalityLevel LocalityLevel_MIN =
    LocalityRouting_LocalityLevel_LocalityLevel_MIN;
  static constexpr LocalityLevel LocalityLevel_MAX =
    LocalityRouting_LocalityLevel_LocalityLevel_MAX;
  static constexpr int LocalityLevel_ARRAYSIZE =
    LocalityRouting_LocalityLevel_LocalityLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocalityLevel_descriptor() {
    return LocalityRouting_LocalityLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& LocalityLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocalityLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocalityLevel_Name.");
    return LocalityRouting_LocalityLevel_Name(enum_t_value);
  }
  static inline bool LocalityLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocalityLevel* value) {
    return LocalityRouting_LocalityLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDegradeFieldNumber = 3,
    kStartingLevelFieldNumber = 1,
    kMaxDegradeLevelFieldNumber = 2,
  };
  // .trafficcontrol.DegradeConfig degrade = 3;
  bool has_degrade() const;
  private:
  bool _internal_has_degrade() const;
  public:
  void clear_degrade();
  const ::trafficcontrol::DegradeConfig& degrade() const;
  PROTOBUF_NODISCARD ::trafficcontrol::DegradeConfig* release_degrade();
  ::trafficcontrol::DegradeConfig* mutable_degrade();
  void set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade);
  private:
  const ::trafficcontrol::DegradeConfig& _internal_degrade() const;
  ::trafficcontrol::DegradeConfig* _internal_mutable_degrade();
  public:
  void unsafe_arena_set_allocated_degrade(
      ::trafficcontrol::DegradeConfig* degrade);
  ::trafficcontrol::DegradeConfig* unsafe_arena_release_degrade();

  // .trafficcontrol.LocalityRouting.LocalityLevel startingLevel = 1;
  void clear_startinglevel();
  ::trafficcontrol::LocalityRouting_LocalityLevel startinglevel() const;
  void set_startinglevel(::trafficcontrol::LocalityRouting_LocalityLevel value);
  private:
  ::trafficcontrol::LocalityRouting_LocalityLevel _internal_startinglevel() const;
  void _internal_set_startinglevel(::trafficcontrol::LocalityRouting_LocalityLevel value);
  public:

  // .trafficcontrol.LocalityRouting.LocalityLevel maxDegradeLevel = 2;
  void clear_maxdegradelevel();
  ::trafficcontrol::LocalityRouting_LocalityLevel maxdegradelevel() const;
  void set_maxdegradelevel(::trafficcontrol::LocalityRouting_LocalityLevel value);
  private:
  ::trafficcontrol::LocalityRouting_LocalityLevel _internal_maxdegradelevel() const;
  void _internal_set_maxdegradelevel(::trafficcontrol::LocalityRouting_LocalityLevel value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.LocalityRouting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trafficcontrol::DegradeConfig* degrade_;
  int startinglevel_;
  int maxdegradelevel_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class MetadataRouting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.MetadataRouting) */ {
 public:
  inline MetadataRouting() : MetadataRouting(nullptr) {}
  ~MetadataRouting() override;
  explicit PROTOBUF_CONSTEXPR MetadataRouting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataRouting(const MetadataRouting& from);
  MetadataRouting(MetadataRouting&& from) noexcept
    : MetadataRouting() {
    *this = ::std::move(from);
  }

  inline MetadataRouting& operator=(const MetadataRouting& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataRouting& operator=(MetadataRouting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataRouting& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataRouting* internal_default_instance() {
    return reinterpret_cast<const MetadataRouting*>(
               &_MetadataRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MetadataRouting& a, MetadataRouting& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataRouting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataRouting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataRouting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataRouting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataRouting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetadataRouting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataRouting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.MetadataRouting";
  }
  protected:
  explicit MetadataRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetadataRouting_DegradeLevel DegradeLevel;
  static constexpr DegradeLevel ALL =
    MetadataRouting_DegradeLevel_ALL;
  static constexpr DegradeLevel OTHERS =
    MetadataRouting_DegradeLevel_OTHERS;
  static inline bool DegradeLevel_IsValid(int value) {
    return MetadataRouting_DegradeLevel_IsValid(value);
  }
  static constexpr DegradeLevel DegradeLevel_MIN =
    MetadataRouting_DegradeLevel_DegradeLevel_MIN;
  static constexpr DegradeLevel DegradeLevel_MAX =
    MetadataRouting_DegradeLevel_DegradeLevel_MAX;
  static constexpr int DegradeLevel_ARRAYSIZE =
    MetadataRouting_DegradeLevel_DegradeLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DegradeLevel_descriptor() {
    return MetadataRouting_DegradeLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& DegradeLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DegradeLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DegradeLevel_Name.");
    return MetadataRouting_DegradeLevel_Name(enum_t_value);
  }
  static inline bool DegradeLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DegradeLevel* value) {
    return MetadataRouting_DegradeLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDegradeFieldNumber = 3,
    kDegradeLevelFieldNumber = 1,
  };
  // .trafficcontrol.DegradeConfig degrade = 3;
  bool has_degrade() const;
  private:
  bool _internal_has_degrade() const;
  public:
  void clear_degrade();
  const ::trafficcontrol::DegradeConfig& degrade() const;
  PROTOBUF_NODISCARD ::trafficcontrol::DegradeConfig* release_degrade();
  ::trafficcontrol::DegradeConfig* mutable_degrade();
  void set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade);
  private:
  const ::trafficcontrol::DegradeConfig& _internal_degrade() const;
  ::trafficcontrol::DegradeConfig* _internal_mutable_degrade();
  public:
  void unsafe_arena_set_allocated_degrade(
      ::trafficcontrol::DegradeConfig* degrade);
  ::trafficcontrol::DegradeConfig* unsafe_arena_release_degrade();

  // .trafficcontrol.MetadataRouting.DegradeLevel degrade_level = 1;
  void clear_degrade_level();
  ::trafficcontrol::MetadataRouting_DegradeLevel degrade_level() const;
  void set_degrade_level(::trafficcontrol::MetadataRouting_DegradeLevel value);
  private:
  ::trafficcontrol::MetadataRouting_DegradeLevel _internal_degrade_level() const;
  void _internal_set_degrade_level(::trafficcontrol::MetadataRouting_DegradeLevel value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.MetadataRouting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trafficcontrol::DegradeConfig* degrade_;
  int degrade_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class CanaryRouting final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.CanaryRouting) */ {
 public:
  inline CanaryRouting() : CanaryRouting(nullptr) {}
  ~CanaryRouting() override;
  explicit PROTOBUF_CONSTEXPR CanaryRouting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CanaryRouting(const CanaryRouting& from);
  CanaryRouting(CanaryRouting&& from) noexcept
    : CanaryRouting() {
    *this = ::std::move(from);
  }

  inline CanaryRouting& operator=(const CanaryRouting& from) {
    CopyFrom(from);
    return *this;
  }
  inline CanaryRouting& operator=(CanaryRouting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CanaryRouting& default_instance() {
    return *internal_default_instance();
  }
  static inline const CanaryRouting* internal_default_instance() {
    return reinterpret_cast<const CanaryRouting*>(
               &_CanaryRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CanaryRouting& a, CanaryRouting& b) {
    a.Swap(&b);
  }
  inline void Swap(CanaryRouting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CanaryRouting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CanaryRouting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CanaryRouting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CanaryRouting& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CanaryRouting& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CanaryRouting* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.CanaryRouting";
  }
  protected:
  explicit CanaryRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CanaryRouting_DegradeLevel DegradeLevel;
  static constexpr DegradeLevel ALL =
    CanaryRouting_DegradeLevel_ALL;
  static constexpr DegradeLevel OTHERS =
    CanaryRouting_DegradeLevel_OTHERS;
  static constexpr DegradeLevel OTHERS_WITHOUT_CANARY =
    CanaryRouting_DegradeLevel_OTHERS_WITHOUT_CANARY;
  static inline bool DegradeLevel_IsValid(int value) {
    return CanaryRouting_DegradeLevel_IsValid(value);
  }
  static constexpr DegradeLevel DegradeLevel_MIN =
    CanaryRouting_DegradeLevel_DegradeLevel_MIN;
  static constexpr DegradeLevel DegradeLevel_MAX =
    CanaryRouting_DegradeLevel_DegradeLevel_MAX;
  static constexpr int DegradeLevel_ARRAYSIZE =
    CanaryRouting_DegradeLevel_DegradeLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  DegradeLevel_descriptor() {
    return CanaryRouting_DegradeLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& DegradeLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, DegradeLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function DegradeLevel_Name.");
    return CanaryRouting_DegradeLevel_Name(enum_t_value);
  }
  static inline bool DegradeLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      DegradeLevel* value) {
    return CanaryRouting_DegradeLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDegradeFieldNumber = 3,
    kDegradeLevelFieldNumber = 1,
  };
  // .trafficcontrol.DegradeConfig degrade = 3;
  bool has_degrade() const;
  private:
  bool _internal_has_degrade() const;
  public:
  void clear_degrade();
  const ::trafficcontrol::DegradeConfig& degrade() const;
  PROTOBUF_NODISCARD ::trafficcontrol::DegradeConfig* release_degrade();
  ::trafficcontrol::DegradeConfig* mutable_degrade();
  void set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade);
  private:
  const ::trafficcontrol::DegradeConfig& _internal_degrade() const;
  ::trafficcontrol::DegradeConfig* _internal_mutable_degrade();
  public:
  void unsafe_arena_set_allocated_degrade(
      ::trafficcontrol::DegradeConfig* degrade);
  ::trafficcontrol::DegradeConfig* unsafe_arena_release_degrade();

  // .trafficcontrol.CanaryRouting.DegradeLevel degrade_level = 1;
  void clear_degrade_level();
  ::trafficcontrol::CanaryRouting_DegradeLevel degrade_level() const;
  void set_degrade_level(::trafficcontrol::CanaryRouting_DegradeLevel value);
  private:
  ::trafficcontrol::CanaryRouting_DegradeLevel _internal_degrade_level() const;
  void _internal_set_degrade_level(::trafficcontrol::CanaryRouting_DegradeLevel value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.CanaryRouting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trafficcontrol::DegradeConfig* degrade_;
  int degrade_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class SetRouting final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:trafficcontrol.SetRouting) */ {
 public:
  inline SetRouting() : SetRouting(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SetRouting(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SetRouting(const SetRouting& from);
  SetRouting(SetRouting&& from) noexcept
    : SetRouting() {
    *this = ::std::move(from);
  }

  inline SetRouting& operator=(const SetRouting& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetRouting& operator=(SetRouting&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetRouting& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetRouting* internal_default_instance() {
    return reinterpret_cast<const SetRouting*>(
               &_SetRouting_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(SetRouting& a, SetRouting& b) {
    a.Swap(&b);
  }
  inline void Swap(SetRouting* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetRouting* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetRouting* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetRouting>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetRouting& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetRouting& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.SetRouting";
  }
  protected:
  explicit SetRouting(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:trafficcontrol.SetRouting)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  friend struct ::TableStruct_router_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RouteConfiguration

// repeated .trafficcontrol.Router routers = 1;
inline int RouteConfiguration::_internal_routers_size() const {
  return routers_.size();
}
inline int RouteConfiguration::routers_size() const {
  return _internal_routers_size();
}
inline void RouteConfiguration::clear_routers() {
  routers_.Clear();
}
inline ::trafficcontrol::Router* RouteConfiguration::mutable_routers(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RouteConfiguration.routers)
  return routers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >*
RouteConfiguration::mutable_routers() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.RouteConfiguration.routers)
  return &routers_;
}
inline const ::trafficcontrol::Router& RouteConfiguration::_internal_routers(int index) const {
  return routers_.Get(index);
}
inline const ::trafficcontrol::Router& RouteConfiguration::routers(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RouteConfiguration.routers)
  return _internal_routers(index);
}
inline ::trafficcontrol::Router* RouteConfiguration::_internal_add_routers() {
  return routers_.Add();
}
inline ::trafficcontrol::Router* RouteConfiguration::add_routers() {
  ::trafficcontrol::Router* _add = _internal_add_routers();
  // @@protoc_insertion_point(field_add:trafficcontrol.RouteConfiguration.routers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >&
RouteConfiguration::routers() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.RouteConfiguration.routers)
  return routers_;
}

// -------------------------------------------------------------------

// Router

// .trafficcontrol.RouterType type = 1;
inline void Router::clear_type() {
  type_ = 0;
}
inline ::trafficcontrol::RouterType Router::_internal_type() const {
  return static_cast< ::trafficcontrol::RouterType >(type_);
}
inline ::trafficcontrol::RouterType Router::type() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Router.type)
  return _internal_type();
}
inline void Router::_internal_set_type(::trafficcontrol::RouterType value) {
  
  type_ = value;
}
inline void Router::set_type(::trafficcontrol::RouterType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.Router.type)
}

// .google.protobuf.Any routing = 2;
inline bool Router::_internal_has_routing() const {
  return this != internal_default_instance() && routing_ != nullptr;
}
inline bool Router::has_routing() const {
  return _internal_has_routing();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Router::_internal_routing() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = routing_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Router::routing() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Router.routing)
  return _internal_routing();
}
inline void Router::unsafe_arena_set_allocated_routing(
    ::PROTOBUF_NAMESPACE_ID::Any* routing) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_);
  }
  routing_ = routing;
  if (routing) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Router.routing)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::release_routing() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = routing_;
  routing_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::unsafe_arena_release_routing() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Router.routing)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = routing_;
  routing_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::_internal_mutable_routing() {
  
  if (routing_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    routing_ = p;
  }
  return routing_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::mutable_routing() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_routing();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Router.routing)
  return _msg;
}
inline void Router::set_allocated_routing(::PROTOBUF_NAMESPACE_ID::Any* routing) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_);
  }
  if (routing) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing));
    if (message_arena != submessage_arena) {
      routing = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing, submessage_arena);
    }
    
  } else {
    
  }
  routing_ = routing;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Router.routing)
}

// -------------------------------------------------------------------

// MatchString

// .trafficcontrol.MatchString.MatchStringType type = 1;
inline void MatchString::clear_type() {
  type_ = 0;
}
inline ::trafficcontrol::MatchString_MatchStringType MatchString::_internal_type() const {
  return static_cast< ::trafficcontrol::MatchString_MatchStringType >(type_);
}
inline ::trafficcontrol::MatchString_MatchStringType MatchString::type() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.type)
  return _internal_type();
}
inline void MatchString::_internal_set_type(::trafficcontrol::MatchString_MatchStringType value) {
  
  type_ = value;
}
inline void MatchString::set_type(::trafficcontrol::MatchString_MatchStringType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MatchString.type)
}

// .google.protobuf.StringValue value = 2;
inline bool MatchString::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool MatchString::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MatchString::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MatchString::value() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.value)
  return _internal_value();
}
inline void MatchString::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::StringValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.MatchString.value)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:trafficcontrol.MatchString.value)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.MatchString.value)
  return _msg;
}
inline void MatchString::set_allocated_value(::PROTOBUF_NAMESPACE_ID::StringValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.MatchString.value)
}

// .trafficcontrol.MatchString.ValueType value_type = 3;
inline void MatchString::clear_value_type() {
  value_type_ = 0;
}
inline ::trafficcontrol::MatchString_ValueType MatchString::_internal_value_type() const {
  return static_cast< ::trafficcontrol::MatchString_ValueType >(value_type_);
}
inline ::trafficcontrol::MatchString_ValueType MatchString::value_type() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.value_type)
  return _internal_value_type();
}
inline void MatchString::_internal_set_value_type(::trafficcontrol::MatchString_ValueType value) {
  
  value_type_ = value;
}
inline void MatchString::set_value_type(::trafficcontrol::MatchString_ValueType value) {
  _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MatchString.value_type)
}

// -------------------------------------------------------------------

// Locality

// .trafficcontrol.MatchString region = 1;
inline bool Locality::_internal_has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline bool Locality::has_region() const {
  return _internal_has_region();
}
inline void Locality::clear_region() {
  if (GetArenaForAllocation() == nullptr && region_ != nullptr) {
    delete region_;
  }
  region_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_region() const {
  const ::trafficcontrol::MatchString* p = region_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::region() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.region)
  return _internal_region();
}
inline void Locality::unsafe_arena_set_allocated_region(
    ::trafficcontrol::MatchString* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  region_ = region;
  if (region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.region)
}
inline ::trafficcontrol::MatchString* Locality::release_region() {
  
  ::trafficcontrol::MatchString* temp = region_;
  region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.region)
  
  ::trafficcontrol::MatchString* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    region_ = p;
  }
  return region_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_region() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.region)
  return _msg;
}
inline void Locality::set_allocated_region(::trafficcontrol::MatchString* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.region)
}

// .trafficcontrol.MatchString zone = 2;
inline bool Locality::_internal_has_zone() const {
  return this != internal_default_instance() && zone_ != nullptr;
}
inline bool Locality::has_zone() const {
  return _internal_has_zone();
}
inline void Locality::clear_zone() {
  if (GetArenaForAllocation() == nullptr && zone_ != nullptr) {
    delete zone_;
  }
  zone_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_zone() const {
  const ::trafficcontrol::MatchString* p = zone_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::zone() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.zone)
  return _internal_zone();
}
inline void Locality::unsafe_arena_set_allocated_zone(
    ::trafficcontrol::MatchString* zone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zone_);
  }
  zone_ = zone;
  if (zone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.zone)
}
inline ::trafficcontrol::MatchString* Locality::release_zone() {
  
  ::trafficcontrol::MatchString* temp = zone_;
  zone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_zone() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.zone)
  
  ::trafficcontrol::MatchString* temp = zone_;
  zone_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_zone() {
  
  if (zone_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    zone_ = p;
  }
  return zone_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_zone() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.zone)
  return _msg;
}
inline void Locality::set_allocated_zone(::trafficcontrol::MatchString* zone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zone_;
  }
  if (zone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zone);
    if (message_arena != submessage_arena) {
      zone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zone, submessage_arena);
    }
    
  } else {
    
  }
  zone_ = zone;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.zone)
}

// .trafficcontrol.MatchString campus = 3;
inline bool Locality::_internal_has_campus() const {
  return this != internal_default_instance() && campus_ != nullptr;
}
inline bool Locality::has_campus() const {
  return _internal_has_campus();
}
inline void Locality::clear_campus() {
  if (GetArenaForAllocation() == nullptr && campus_ != nullptr) {
    delete campus_;
  }
  campus_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_campus() const {
  const ::trafficcontrol::MatchString* p = campus_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::campus() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.campus)
  return _internal_campus();
}
inline void Locality::unsafe_arena_set_allocated_campus(
    ::trafficcontrol::MatchString* campus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(campus_);
  }
  campus_ = campus;
  if (campus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.campus)
}
inline ::trafficcontrol::MatchString* Locality::release_campus() {
  
  ::trafficcontrol::MatchString* temp = campus_;
  campus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_campus() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.campus)
  
  ::trafficcontrol::MatchString* temp = campus_;
  campus_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_campus() {
  
  if (campus_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    campus_ = p;
  }
  return campus_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_campus() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_campus();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.campus)
  return _msg;
}
inline void Locality::set_allocated_campus(::trafficcontrol::MatchString* campus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete campus_;
  }
  if (campus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(campus);
    if (message_arena != submessage_arena) {
      campus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, campus, submessage_arena);
    }
    
  } else {
    
  }
  campus_ = campus;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.campus)
}

// -------------------------------------------------------------------

// DegradeConfig

// .google.protobuf.BoolValue enable = 1;
inline bool DegradeConfig::_internal_has_enable() const {
  return this != internal_default_instance() && enable_ != nullptr;
}
inline bool DegradeConfig::has_enable() const {
  return _internal_has_enable();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& DegradeConfig::_internal_enable() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = enable_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& DegradeConfig::enable() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.DegradeConfig.enable)
  return _internal_enable();
}
inline void DegradeConfig::unsafe_arena_set_allocated_enable(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  enable_ = enable;
  if (enable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.DegradeConfig.enable)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* DegradeConfig::release_enable() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* DegradeConfig::unsafe_arena_release_enable() {
  // @@protoc_insertion_point(field_release:trafficcontrol.DegradeConfig.enable)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* DegradeConfig::_internal_mutable_enable() {
  
  if (enable_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    enable_ = p;
  }
  return enable_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* DegradeConfig::mutable_enable() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_enable();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.DegradeConfig.enable)
  return _msg;
}
inline void DegradeConfig::set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  if (enable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable));
    if (message_arena != submessage_arena) {
      enable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enable, submessage_arena);
    }
    
  } else {
    
  }
  enable_ = enable;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.DegradeConfig.enable)
}

// .google.protobuf.UInt32Value total_count = 2;
inline bool DegradeConfig::_internal_has_total_count() const {
  return this != internal_default_instance() && total_count_ != nullptr;
}
inline bool DegradeConfig::has_total_count() const {
  return _internal_has_total_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::_internal_total_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = total_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::total_count() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.DegradeConfig.total_count)
  return _internal_total_count();
}
inline void DegradeConfig::unsafe_arena_set_allocated_total_count(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count_);
  }
  total_count_ = total_count;
  if (total_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.DegradeConfig.total_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::release_total_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = total_count_;
  total_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::unsafe_arena_release_total_count() {
  // @@protoc_insertion_point(field_release:trafficcontrol.DegradeConfig.total_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = total_count_;
  total_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::_internal_mutable_total_count() {
  
  if (total_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    total_count_ = p;
  }
  return total_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::mutable_total_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_total_count();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.DegradeConfig.total_count)
  return _msg;
}
inline void DegradeConfig::set_allocated_total_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count_);
  }
  if (total_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count));
    if (message_arena != submessage_arena) {
      total_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total_count, submessage_arena);
    }
    
  } else {
    
  }
  total_count_ = total_count;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.DegradeConfig.total_count)
}

// .google.protobuf.UInt32Value healthy_count = 3;
inline bool DegradeConfig::_internal_has_healthy_count() const {
  return this != internal_default_instance() && healthy_count_ != nullptr;
}
inline bool DegradeConfig::has_healthy_count() const {
  return _internal_has_healthy_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::_internal_healthy_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = healthy_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::healthy_count() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.DegradeConfig.healthy_count)
  return _internal_healthy_count();
}
inline void DegradeConfig::unsafe_arena_set_allocated_healthy_count(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count_);
  }
  healthy_count_ = healthy_count;
  if (healthy_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.DegradeConfig.healthy_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::release_healthy_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_count_;
  healthy_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::unsafe_arena_release_healthy_count() {
  // @@protoc_insertion_point(field_release:trafficcontrol.DegradeConfig.healthy_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_count_;
  healthy_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::_internal_mutable_healthy_count() {
  
  if (healthy_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    healthy_count_ = p;
  }
  return healthy_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::mutable_healthy_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_healthy_count();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.DegradeConfig.healthy_count)
  return _msg;
}
inline void DegradeConfig::set_allocated_healthy_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count_);
  }
  if (healthy_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count));
    if (message_arena != submessage_arena) {
      healthy_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, healthy_count, submessage_arena);
    }
    
  } else {
    
  }
  healthy_count_ = healthy_count;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.DegradeConfig.healthy_count)
}

// .google.protobuf.UInt32Value healthy_percent = 4;
inline bool DegradeConfig::_internal_has_healthy_percent() const {
  return this != internal_default_instance() && healthy_percent_ != nullptr;
}
inline bool DegradeConfig::has_healthy_percent() const {
  return _internal_has_healthy_percent();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::_internal_healthy_percent() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = healthy_percent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& DegradeConfig::healthy_percent() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.DegradeConfig.healthy_percent)
  return _internal_healthy_percent();
}
inline void DegradeConfig::unsafe_arena_set_allocated_healthy_percent(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent_);
  }
  healthy_percent_ = healthy_percent;
  if (healthy_percent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.DegradeConfig.healthy_percent)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::release_healthy_percent() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_percent_;
  healthy_percent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::unsafe_arena_release_healthy_percent() {
  // @@protoc_insertion_point(field_release:trafficcontrol.DegradeConfig.healthy_percent)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_percent_;
  healthy_percent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::_internal_mutable_healthy_percent() {
  
  if (healthy_percent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    healthy_percent_ = p;
  }
  return healthy_percent_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* DegradeConfig::mutable_healthy_percent() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_healthy_percent();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.DegradeConfig.healthy_percent)
  return _msg;
}
inline void DegradeConfig::set_allocated_healthy_percent(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent_);
  }
  if (healthy_percent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent));
    if (message_arena != submessage_arena) {
      healthy_percent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, healthy_percent, submessage_arena);
    }
    
  } else {
    
  }
  healthy_percent_ = healthy_percent;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.DegradeConfig.healthy_percent)
}

// -------------------------------------------------------------------

// RuleRouting

// .google.protobuf.StringValue namespace = 1;
inline bool RuleRouting::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool RuleRouting::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& RuleRouting::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& RuleRouting::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRouting.namespace)
  return _internal_namespace_();
}
inline void RuleRouting::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.RuleRouting.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.RuleRouting.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRouting.namespace)
  return _msg;
}
inline void RuleRouting::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.RuleRouting.namespace)
}

// .google.protobuf.StringValue service = 2;
inline bool RuleRouting::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool RuleRouting::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& RuleRouting::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& RuleRouting::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRouting.service)
  return _internal_service();
}
inline void RuleRouting::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.RuleRouting.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.RuleRouting.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* RuleRouting::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRouting.service)
  return _msg;
}
inline void RuleRouting::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.RuleRouting.service)
}

// repeated .trafficcontrol.Route inbounds = 3;
inline int RuleRouting::_internal_inbounds_size() const {
  return inbounds_.size();
}
inline int RuleRouting::inbounds_size() const {
  return _internal_inbounds_size();
}
inline void RuleRouting::clear_inbounds() {
  inbounds_.Clear();
}
inline ::trafficcontrol::Route* RuleRouting::mutable_inbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRouting.inbounds)
  return inbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
RuleRouting::mutable_inbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.RuleRouting.inbounds)
  return &inbounds_;
}
inline const ::trafficcontrol::Route& RuleRouting::_internal_inbounds(int index) const {
  return inbounds_.Get(index);
}
inline const ::trafficcontrol::Route& RuleRouting::inbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRouting.inbounds)
  return _internal_inbounds(index);
}
inline ::trafficcontrol::Route* RuleRouting::_internal_add_inbounds() {
  return inbounds_.Add();
}
inline ::trafficcontrol::Route* RuleRouting::add_inbounds() {
  ::trafficcontrol::Route* _add = _internal_add_inbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.RuleRouting.inbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
RuleRouting::inbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.RuleRouting.inbounds)
  return inbounds_;
}

// repeated .trafficcontrol.Route outbounds = 4;
inline int RuleRouting::_internal_outbounds_size() const {
  return outbounds_.size();
}
inline int RuleRouting::outbounds_size() const {
  return _internal_outbounds_size();
}
inline void RuleRouting::clear_outbounds() {
  outbounds_.Clear();
}
inline ::trafficcontrol::Route* RuleRouting::mutable_outbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRouting.outbounds)
  return outbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
RuleRouting::mutable_outbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.RuleRouting.outbounds)
  return &outbounds_;
}
inline const ::trafficcontrol::Route& RuleRouting::_internal_outbounds(int index) const {
  return outbounds_.Get(index);
}
inline const ::trafficcontrol::Route& RuleRouting::outbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRouting.outbounds)
  return _internal_outbounds(index);
}
inline ::trafficcontrol::Route* RuleRouting::_internal_add_outbounds() {
  return outbounds_.Add();
}
inline ::trafficcontrol::Route* RuleRouting::add_outbounds() {
  ::trafficcontrol::Route* _add = _internal_add_outbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.RuleRouting.outbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
RuleRouting::outbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.RuleRouting.outbounds)
  return outbounds_;
}

// .trafficcontrol.DegradeConfig degrade = 5;
inline bool RuleRouting::_internal_has_degrade() const {
  return this != internal_default_instance() && degrade_ != nullptr;
}
inline bool RuleRouting::has_degrade() const {
  return _internal_has_degrade();
}
inline void RuleRouting::clear_degrade() {
  if (GetArenaForAllocation() == nullptr && degrade_ != nullptr) {
    delete degrade_;
  }
  degrade_ = nullptr;
}
inline const ::trafficcontrol::DegradeConfig& RuleRouting::_internal_degrade() const {
  const ::trafficcontrol::DegradeConfig* p = degrade_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::DegradeConfig&>(
      ::trafficcontrol::_DegradeConfig_default_instance_);
}
inline const ::trafficcontrol::DegradeConfig& RuleRouting::degrade() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRouting.degrade)
  return _internal_degrade();
}
inline void RuleRouting::unsafe_arena_set_allocated_degrade(
    ::trafficcontrol::DegradeConfig* degrade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(degrade_);
  }
  degrade_ = degrade;
  if (degrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.RuleRouting.degrade)
}
inline ::trafficcontrol::DegradeConfig* RuleRouting::release_degrade() {
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::DegradeConfig* RuleRouting::unsafe_arena_release_degrade() {
  // @@protoc_insertion_point(field_release:trafficcontrol.RuleRouting.degrade)
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
  return temp;
}
inline ::trafficcontrol::DegradeConfig* RuleRouting::_internal_mutable_degrade() {
  
  if (degrade_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::DegradeConfig>(GetArenaForAllocation());
    degrade_ = p;
  }
  return degrade_;
}
inline ::trafficcontrol::DegradeConfig* RuleRouting::mutable_degrade() {
  ::trafficcontrol::DegradeConfig* _msg = _internal_mutable_degrade();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRouting.degrade)
  return _msg;
}
inline void RuleRouting::set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete degrade_;
  }
  if (degrade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(degrade);
    if (message_arena != submessage_arena) {
      degrade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, degrade, submessage_arena);
    }
    
  } else {
    
  }
  degrade_ = degrade;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.RuleRouting.degrade)
}

// -------------------------------------------------------------------

// Route

// repeated .trafficcontrol.Source sources = 1;
inline int Route::_internal_sources_size() const {
  return sources_.size();
}
inline int Route::sources_size() const {
  return _internal_sources_size();
}
inline void Route::clear_sources() {
  sources_.Clear();
}
inline ::trafficcontrol::Source* Route::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Route.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >*
Route::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Route.sources)
  return &sources_;
}
inline const ::trafficcontrol::Source& Route::_internal_sources(int index) const {
  return sources_.Get(index);
}
inline const ::trafficcontrol::Source& Route::sources(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Route.sources)
  return _internal_sources(index);
}
inline ::trafficcontrol::Source* Route::_internal_add_sources() {
  return sources_.Add();
}
inline ::trafficcontrol::Source* Route::add_sources() {
  ::trafficcontrol::Source* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:trafficcontrol.Route.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >&
Route::sources() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Route.sources)
  return sources_;
}

// repeated .trafficcontrol.Destination destinations = 2;
inline int Route::_internal_destinations_size() const {
  return destinations_.size();
}
inline int Route::destinations_size() const {
  return _internal_destinations_size();
}
inline void Route::clear_destinations() {
  destinations_.Clear();
}
inline ::trafficcontrol::Destination* Route::mutable_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Route.destinations)
  return destinations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >*
Route::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Route.destinations)
  return &destinations_;
}
inline const ::trafficcontrol::Destination& Route::_internal_destinations(int index) const {
  return destinations_.Get(index);
}
inline const ::trafficcontrol::Destination& Route::destinations(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Route.destinations)
  return _internal_destinations(index);
}
inline ::trafficcontrol::Destination* Route::_internal_add_destinations() {
  return destinations_.Add();
}
inline ::trafficcontrol::Destination* Route::add_destinations() {
  ::trafficcontrol::Destination* _add = _internal_add_destinations();
  // @@protoc_insertion_point(field_add:trafficcontrol.Route.destinations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >&
Route::destinations() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Route.destinations)
  return destinations_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Source

// .google.protobuf.StringValue service = 1;
inline bool Source::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool Source::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.service)
  return _internal_service();
}
inline void Source::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.service)
  return _msg;
}
inline void Source::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.service)
}

// .google.protobuf.StringValue namespace = 2;
inline bool Source::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Source::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.namespace)
  return _internal_namespace_();
}
inline void Source::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.namespace)
  return _msg;
}
inline void Source::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.namespace)
}

// map<string, .trafficcontrol.MatchString> metadata = 3;
inline int Source::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Source::metadata_size() const {
  return _internal_metadata_size();
}
inline void Source::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Source::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Source::metadata() const {
  // @@protoc_insertion_point(field_map:trafficcontrol.Source.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Source::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Source::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:trafficcontrol.Source.metadata)
  return _internal_mutable_metadata();
}

// .trafficcontrol.Locality locality = 4;
inline bool Source::_internal_has_locality() const {
  return this != internal_default_instance() && locality_ != nullptr;
}
inline bool Source::has_locality() const {
  return _internal_has_locality();
}
inline void Source::clear_locality() {
  if (GetArenaForAllocation() == nullptr && locality_ != nullptr) {
    delete locality_;
  }
  locality_ = nullptr;
}
inline const ::trafficcontrol::Locality& Source::_internal_locality() const {
  const ::trafficcontrol::Locality* p = locality_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::Locality&>(
      ::trafficcontrol::_Locality_default_instance_);
}
inline const ::trafficcontrol::Locality& Source::locality() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.locality)
  return _internal_locality();
}
inline void Source::unsafe_arena_set_allocated_locality(
    ::trafficcontrol::Locality* locality) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locality_);
  }
  locality_ = locality;
  if (locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.locality)
}
inline ::trafficcontrol::Locality* Source::release_locality() {
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::Locality* Source::unsafe_arena_release_locality() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.locality)
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
  return temp;
}
inline ::trafficcontrol::Locality* Source::_internal_mutable_locality() {
  
  if (locality_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::Locality>(GetArenaForAllocation());
    locality_ = p;
  }
  return locality_;
}
inline ::trafficcontrol::Locality* Source::mutable_locality() {
  ::trafficcontrol::Locality* _msg = _internal_mutable_locality();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.locality)
  return _msg;
}
inline void Source::set_allocated_locality(::trafficcontrol::Locality* locality) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete locality_;
  }
  if (locality) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locality);
    if (message_arena != submessage_arena) {
      locality = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locality, submessage_arena);
    }
    
  } else {
    
  }
  locality_ = locality;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.locality)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Destination

// .google.protobuf.StringValue service = 1;
inline bool Destination::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool Destination::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.service)
  return _internal_service();
}
inline void Destination::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.service)
  return _msg;
}
inline void Destination::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.service)
}

// .google.protobuf.StringValue namespace = 2;
inline bool Destination::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Destination::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.namespace)
  return _internal_namespace_();
}
inline void Destination::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.namespace)
  return _msg;
}
inline void Destination::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.namespace)
}

// map<string, .trafficcontrol.MatchString> metadata = 3;
inline int Destination::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Destination::metadata_size() const {
  return _internal_metadata_size();
}
inline void Destination::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Destination::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Destination::metadata() const {
  // @@protoc_insertion_point(field_map:trafficcontrol.Destination.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Destination::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Destination::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:trafficcontrol.Destination.metadata)
  return _internal_mutable_metadata();
}

// .google.protobuf.UInt32Value priority = 4;
inline bool Destination::_internal_has_priority() const {
  return this != internal_default_instance() && priority_ != nullptr;
}
inline bool Destination::has_priority() const {
  return _internal_has_priority();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::_internal_priority() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::priority() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.priority)
  return _internal_priority();
}
inline void Destination::unsafe_arena_set_allocated_priority(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority_);
  }
  priority_ = priority;
  if (priority) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.priority)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::release_priority() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = priority_;
  priority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::unsafe_arena_release_priority() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.priority)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = priority_;
  priority_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::_internal_mutable_priority() {
  
  if (priority_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    priority_ = p;
  }
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::mutable_priority() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.priority)
  return _msg;
}
inline void Destination::set_allocated_priority(::PROTOBUF_NAMESPACE_ID::UInt32Value* priority) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority_);
  }
  if (priority) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority));
    if (message_arena != submessage_arena) {
      priority = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    
  } else {
    
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.priority)
}

// .google.protobuf.UInt32Value weight = 5;
inline bool Destination::_internal_has_weight() const {
  return this != internal_default_instance() && weight_ != nullptr;
}
inline bool Destination::has_weight() const {
  return _internal_has_weight();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::_internal_weight() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = weight_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::weight() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.weight)
  return _internal_weight();
}
inline void Destination::unsafe_arena_set_allocated_weight(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight_);
  }
  weight_ = weight;
  if (weight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.weight)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::release_weight() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = weight_;
  weight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::unsafe_arena_release_weight() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.weight)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = weight_;
  weight_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::_internal_mutable_weight() {
  
  if (weight_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    weight_ = p;
  }
  return weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::mutable_weight() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_weight();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.weight)
  return _msg;
}
inline void Destination::set_allocated_weight(::PROTOBUF_NAMESPACE_ID::UInt32Value* weight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight_);
  }
  if (weight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight));
    if (message_arena != submessage_arena) {
      weight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weight, submessage_arena);
    }
    
  } else {
    
  }
  weight_ = weight;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.weight)
}

// .google.protobuf.StringValue transfer = 6;
inline bool Destination::_internal_has_transfer() const {
  return this != internal_default_instance() && transfer_ != nullptr;
}
inline bool Destination::has_transfer() const {
  return _internal_has_transfer();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_transfer() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = transfer_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::transfer() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.transfer)
  return _internal_transfer();
}
inline void Destination::unsafe_arena_set_allocated_transfer(
    ::PROTOBUF_NAMESPACE_ID::StringValue* transfer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_);
  }
  transfer_ = transfer;
  if (transfer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.transfer)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_transfer() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = transfer_;
  transfer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.transfer)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = transfer_;
  transfer_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_transfer() {
  
  if (transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    transfer_ = p;
  }
  return transfer_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_transfer() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_transfer();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.transfer)
  return _msg;
}
inline void Destination::set_allocated_transfer(::PROTOBUF_NAMESPACE_ID::StringValue* transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_);
  }
  if (transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer));
    if (message_arena != submessage_arena) {
      transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    
  } else {
    
  }
  transfer_ = transfer;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.transfer)
}

// .google.protobuf.BoolValue isolate = 7;
inline bool Destination::_internal_has_isolate() const {
  return this != internal_default_instance() && isolate_ != nullptr;
}
inline bool Destination::has_isolate() const {
  return _internal_has_isolate();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Destination::_internal_isolate() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = isolate_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Destination::isolate() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.isolate)
  return _internal_isolate();
}
inline void Destination::unsafe_arena_set_allocated_isolate(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate_);
  }
  isolate_ = isolate;
  if (isolate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.isolate)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::release_isolate() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = isolate_;
  isolate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::unsafe_arena_release_isolate() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.isolate)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = isolate_;
  isolate_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::_internal_mutable_isolate() {
  
  if (isolate_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    isolate_ = p;
  }
  return isolate_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::mutable_isolate() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_isolate();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.isolate)
  return _msg;
}
inline void Destination::set_allocated_isolate(::PROTOBUF_NAMESPACE_ID::BoolValue* isolate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate_);
  }
  if (isolate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate));
    if (message_arena != submessage_arena) {
      isolate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, isolate, submessage_arena);
    }
    
  } else {
    
  }
  isolate_ = isolate;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.isolate)
}

// .trafficcontrol.Locality locality = 8;
inline bool Destination::_internal_has_locality() const {
  return this != internal_default_instance() && locality_ != nullptr;
}
inline bool Destination::has_locality() const {
  return _internal_has_locality();
}
inline void Destination::clear_locality() {
  if (GetArenaForAllocation() == nullptr && locality_ != nullptr) {
    delete locality_;
  }
  locality_ = nullptr;
}
inline const ::trafficcontrol::Locality& Destination::_internal_locality() const {
  const ::trafficcontrol::Locality* p = locality_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::Locality&>(
      ::trafficcontrol::_Locality_default_instance_);
}
inline const ::trafficcontrol::Locality& Destination::locality() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.locality)
  return _internal_locality();
}
inline void Destination::unsafe_arena_set_allocated_locality(
    ::trafficcontrol::Locality* locality) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locality_);
  }
  locality_ = locality;
  if (locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.locality)
}
inline ::trafficcontrol::Locality* Destination::release_locality() {
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::Locality* Destination::unsafe_arena_release_locality() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.locality)
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
  return temp;
}
inline ::trafficcontrol::Locality* Destination::_internal_mutable_locality() {
  
  if (locality_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::Locality>(GetArenaForAllocation());
    locality_ = p;
  }
  return locality_;
}
inline ::trafficcontrol::Locality* Destination::mutable_locality() {
  ::trafficcontrol::Locality* _msg = _internal_mutable_locality();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.locality)
  return _msg;
}
inline void Destination::set_allocated_locality(::trafficcontrol::Locality* locality) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete locality_;
  }
  if (locality) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locality);
    if (message_arena != submessage_arena) {
      locality = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locality, submessage_arena);
    }
    
  } else {
    
  }
  locality_ = locality;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.locality)
}

// -------------------------------------------------------------------

// LocalityRouting

// .trafficcontrol.LocalityRouting.LocalityLevel startingLevel = 1;
inline void LocalityRouting::clear_startinglevel() {
  startinglevel_ = 0;
}
inline ::trafficcontrol::LocalityRouting_LocalityLevel LocalityRouting::_internal_startinglevel() const {
  return static_cast< ::trafficcontrol::LocalityRouting_LocalityLevel >(startinglevel_);
}
inline ::trafficcontrol::LocalityRouting_LocalityLevel LocalityRouting::startinglevel() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.LocalityRouting.startingLevel)
  return _internal_startinglevel();
}
inline void LocalityRouting::_internal_set_startinglevel(::trafficcontrol::LocalityRouting_LocalityLevel value) {
  
  startinglevel_ = value;
}
inline void LocalityRouting::set_startinglevel(::trafficcontrol::LocalityRouting_LocalityLevel value) {
  _internal_set_startinglevel(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.LocalityRouting.startingLevel)
}

// .trafficcontrol.LocalityRouting.LocalityLevel maxDegradeLevel = 2;
inline void LocalityRouting::clear_maxdegradelevel() {
  maxdegradelevel_ = 0;
}
inline ::trafficcontrol::LocalityRouting_LocalityLevel LocalityRouting::_internal_maxdegradelevel() const {
  return static_cast< ::trafficcontrol::LocalityRouting_LocalityLevel >(maxdegradelevel_);
}
inline ::trafficcontrol::LocalityRouting_LocalityLevel LocalityRouting::maxdegradelevel() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.LocalityRouting.maxDegradeLevel)
  return _internal_maxdegradelevel();
}
inline void LocalityRouting::_internal_set_maxdegradelevel(::trafficcontrol::LocalityRouting_LocalityLevel value) {
  
  maxdegradelevel_ = value;
}
inline void LocalityRouting::set_maxdegradelevel(::trafficcontrol::LocalityRouting_LocalityLevel value) {
  _internal_set_maxdegradelevel(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.LocalityRouting.maxDegradeLevel)
}

// .trafficcontrol.DegradeConfig degrade = 3;
inline bool LocalityRouting::_internal_has_degrade() const {
  return this != internal_default_instance() && degrade_ != nullptr;
}
inline bool LocalityRouting::has_degrade() const {
  return _internal_has_degrade();
}
inline void LocalityRouting::clear_degrade() {
  if (GetArenaForAllocation() == nullptr && degrade_ != nullptr) {
    delete degrade_;
  }
  degrade_ = nullptr;
}
inline const ::trafficcontrol::DegradeConfig& LocalityRouting::_internal_degrade() const {
  const ::trafficcontrol::DegradeConfig* p = degrade_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::DegradeConfig&>(
      ::trafficcontrol::_DegradeConfig_default_instance_);
}
inline const ::trafficcontrol::DegradeConfig& LocalityRouting::degrade() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.LocalityRouting.degrade)
  return _internal_degrade();
}
inline void LocalityRouting::unsafe_arena_set_allocated_degrade(
    ::trafficcontrol::DegradeConfig* degrade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(degrade_);
  }
  degrade_ = degrade;
  if (degrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.LocalityRouting.degrade)
}
inline ::trafficcontrol::DegradeConfig* LocalityRouting::release_degrade() {
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::DegradeConfig* LocalityRouting::unsafe_arena_release_degrade() {
  // @@protoc_insertion_point(field_release:trafficcontrol.LocalityRouting.degrade)
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
  return temp;
}
inline ::trafficcontrol::DegradeConfig* LocalityRouting::_internal_mutable_degrade() {
  
  if (degrade_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::DegradeConfig>(GetArenaForAllocation());
    degrade_ = p;
  }
  return degrade_;
}
inline ::trafficcontrol::DegradeConfig* LocalityRouting::mutable_degrade() {
  ::trafficcontrol::DegradeConfig* _msg = _internal_mutable_degrade();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.LocalityRouting.degrade)
  return _msg;
}
inline void LocalityRouting::set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete degrade_;
  }
  if (degrade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(degrade);
    if (message_arena != submessage_arena) {
      degrade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, degrade, submessage_arena);
    }
    
  } else {
    
  }
  degrade_ = degrade;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.LocalityRouting.degrade)
}

// -------------------------------------------------------------------

// MetadataRouting

// .trafficcontrol.MetadataRouting.DegradeLevel degrade_level = 1;
inline void MetadataRouting::clear_degrade_level() {
  degrade_level_ = 0;
}
inline ::trafficcontrol::MetadataRouting_DegradeLevel MetadataRouting::_internal_degrade_level() const {
  return static_cast< ::trafficcontrol::MetadataRouting_DegradeLevel >(degrade_level_);
}
inline ::trafficcontrol::MetadataRouting_DegradeLevel MetadataRouting::degrade_level() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MetadataRouting.degrade_level)
  return _internal_degrade_level();
}
inline void MetadataRouting::_internal_set_degrade_level(::trafficcontrol::MetadataRouting_DegradeLevel value) {
  
  degrade_level_ = value;
}
inline void MetadataRouting::set_degrade_level(::trafficcontrol::MetadataRouting_DegradeLevel value) {
  _internal_set_degrade_level(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MetadataRouting.degrade_level)
}

// .trafficcontrol.DegradeConfig degrade = 3;
inline bool MetadataRouting::_internal_has_degrade() const {
  return this != internal_default_instance() && degrade_ != nullptr;
}
inline bool MetadataRouting::has_degrade() const {
  return _internal_has_degrade();
}
inline void MetadataRouting::clear_degrade() {
  if (GetArenaForAllocation() == nullptr && degrade_ != nullptr) {
    delete degrade_;
  }
  degrade_ = nullptr;
}
inline const ::trafficcontrol::DegradeConfig& MetadataRouting::_internal_degrade() const {
  const ::trafficcontrol::DegradeConfig* p = degrade_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::DegradeConfig&>(
      ::trafficcontrol::_DegradeConfig_default_instance_);
}
inline const ::trafficcontrol::DegradeConfig& MetadataRouting::degrade() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MetadataRouting.degrade)
  return _internal_degrade();
}
inline void MetadataRouting::unsafe_arena_set_allocated_degrade(
    ::trafficcontrol::DegradeConfig* degrade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(degrade_);
  }
  degrade_ = degrade;
  if (degrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.MetadataRouting.degrade)
}
inline ::trafficcontrol::DegradeConfig* MetadataRouting::release_degrade() {
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::DegradeConfig* MetadataRouting::unsafe_arena_release_degrade() {
  // @@protoc_insertion_point(field_release:trafficcontrol.MetadataRouting.degrade)
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
  return temp;
}
inline ::trafficcontrol::DegradeConfig* MetadataRouting::_internal_mutable_degrade() {
  
  if (degrade_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::DegradeConfig>(GetArenaForAllocation());
    degrade_ = p;
  }
  return degrade_;
}
inline ::trafficcontrol::DegradeConfig* MetadataRouting::mutable_degrade() {
  ::trafficcontrol::DegradeConfig* _msg = _internal_mutable_degrade();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.MetadataRouting.degrade)
  return _msg;
}
inline void MetadataRouting::set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete degrade_;
  }
  if (degrade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(degrade);
    if (message_arena != submessage_arena) {
      degrade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, degrade, submessage_arena);
    }
    
  } else {
    
  }
  degrade_ = degrade;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.MetadataRouting.degrade)
}

// -------------------------------------------------------------------

// CanaryRouting

// .trafficcontrol.CanaryRouting.DegradeLevel degrade_level = 1;
inline void CanaryRouting::clear_degrade_level() {
  degrade_level_ = 0;
}
inline ::trafficcontrol::CanaryRouting_DegradeLevel CanaryRouting::_internal_degrade_level() const {
  return static_cast< ::trafficcontrol::CanaryRouting_DegradeLevel >(degrade_level_);
}
inline ::trafficcontrol::CanaryRouting_DegradeLevel CanaryRouting::degrade_level() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.CanaryRouting.degrade_level)
  return _internal_degrade_level();
}
inline void CanaryRouting::_internal_set_degrade_level(::trafficcontrol::CanaryRouting_DegradeLevel value) {
  
  degrade_level_ = value;
}
inline void CanaryRouting::set_degrade_level(::trafficcontrol::CanaryRouting_DegradeLevel value) {
  _internal_set_degrade_level(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.CanaryRouting.degrade_level)
}

// .trafficcontrol.DegradeConfig degrade = 3;
inline bool CanaryRouting::_internal_has_degrade() const {
  return this != internal_default_instance() && degrade_ != nullptr;
}
inline bool CanaryRouting::has_degrade() const {
  return _internal_has_degrade();
}
inline void CanaryRouting::clear_degrade() {
  if (GetArenaForAllocation() == nullptr && degrade_ != nullptr) {
    delete degrade_;
  }
  degrade_ = nullptr;
}
inline const ::trafficcontrol::DegradeConfig& CanaryRouting::_internal_degrade() const {
  const ::trafficcontrol::DegradeConfig* p = degrade_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::DegradeConfig&>(
      ::trafficcontrol::_DegradeConfig_default_instance_);
}
inline const ::trafficcontrol::DegradeConfig& CanaryRouting::degrade() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.CanaryRouting.degrade)
  return _internal_degrade();
}
inline void CanaryRouting::unsafe_arena_set_allocated_degrade(
    ::trafficcontrol::DegradeConfig* degrade) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(degrade_);
  }
  degrade_ = degrade;
  if (degrade) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.CanaryRouting.degrade)
}
inline ::trafficcontrol::DegradeConfig* CanaryRouting::release_degrade() {
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::DegradeConfig* CanaryRouting::unsafe_arena_release_degrade() {
  // @@protoc_insertion_point(field_release:trafficcontrol.CanaryRouting.degrade)
  
  ::trafficcontrol::DegradeConfig* temp = degrade_;
  degrade_ = nullptr;
  return temp;
}
inline ::trafficcontrol::DegradeConfig* CanaryRouting::_internal_mutable_degrade() {
  
  if (degrade_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::DegradeConfig>(GetArenaForAllocation());
    degrade_ = p;
  }
  return degrade_;
}
inline ::trafficcontrol::DegradeConfig* CanaryRouting::mutable_degrade() {
  ::trafficcontrol::DegradeConfig* _msg = _internal_mutable_degrade();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.CanaryRouting.degrade)
  return _msg;
}
inline void CanaryRouting::set_allocated_degrade(::trafficcontrol::DegradeConfig* degrade) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete degrade_;
  }
  if (degrade) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(degrade);
    if (message_arena != submessage_arena) {
      degrade = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, degrade, submessage_arena);
    }
    
  } else {
    
  }
  degrade_ = degrade;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.CanaryRouting.degrade)
}

// -------------------------------------------------------------------

// SetRouting

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trafficcontrol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::trafficcontrol::MatchString_MatchStringType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MatchString_MatchStringType>() {
  return ::trafficcontrol::MatchString_MatchStringType_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::MatchString_ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MatchString_ValueType>() {
  return ::trafficcontrol::MatchString_ValueType_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::LocalityRouting_LocalityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::LocalityRouting_LocalityLevel>() {
  return ::trafficcontrol::LocalityRouting_LocalityLevel_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::MetadataRouting_DegradeLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MetadataRouting_DegradeLevel>() {
  return ::trafficcontrol::MetadataRouting_DegradeLevel_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::CanaryRouting_DegradeLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::CanaryRouting_DegradeLevel>() {
  return ::trafficcontrol::CanaryRouting_DegradeLevel_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::RouterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::RouterType>() {
  return ::trafficcontrol::RouterType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_2eproto
