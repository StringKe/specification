// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: router.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_router_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_router_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/wrappers.pb.h>
#include <google/protobuf/any.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_router_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_router_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_router_2eproto;
namespace trafficcontrol {
class Destination;
struct DestinationDefaultTypeInternal;
extern DestinationDefaultTypeInternal _Destination_default_instance_;
class Destination_MetadataEntry_DoNotUse;
struct Destination_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Destination_MetadataEntry_DoNotUseDefaultTypeInternal _Destination_MetadataEntry_DoNotUse_default_instance_;
class FailoverConfig;
struct FailoverConfigDefaultTypeInternal;
extern FailoverConfigDefaultTypeInternal _FailoverConfig_default_instance_;
class Locality;
struct LocalityDefaultTypeInternal;
extern LocalityDefaultTypeInternal _Locality_default_instance_;
class LocalityRoutingConfig;
struct LocalityRoutingConfigDefaultTypeInternal;
extern LocalityRoutingConfigDefaultTypeInternal _LocalityRoutingConfig_default_instance_;
class MatchString;
struct MatchStringDefaultTypeInternal;
extern MatchStringDefaultTypeInternal _MatchString_default_instance_;
class MetadataRoutingConfig;
struct MetadataRoutingConfigDefaultTypeInternal;
extern MetadataRoutingConfigDefaultTypeInternal _MetadataRoutingConfig_default_instance_;
class Route;
struct RouteDefaultTypeInternal;
extern RouteDefaultTypeInternal _Route_default_instance_;
class Router;
struct RouterDefaultTypeInternal;
extern RouterDefaultTypeInternal _Router_default_instance_;
class Routing;
struct RoutingDefaultTypeInternal;
extern RoutingDefaultTypeInternal _Routing_default_instance_;
class RuleRoutingConfig;
struct RuleRoutingConfigDefaultTypeInternal;
extern RuleRoutingConfigDefaultTypeInternal _RuleRoutingConfig_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class Source_MetadataEntry_DoNotUse;
struct Source_MetadataEntry_DoNotUseDefaultTypeInternal;
extern Source_MetadataEntry_DoNotUseDefaultTypeInternal _Source_MetadataEntry_DoNotUse_default_instance_;
}  // namespace trafficcontrol
PROTOBUF_NAMESPACE_OPEN
template<> ::trafficcontrol::Destination* Arena::CreateMaybeMessage<::trafficcontrol::Destination>(Arena*);
template<> ::trafficcontrol::Destination_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::trafficcontrol::Destination_MetadataEntry_DoNotUse>(Arena*);
template<> ::trafficcontrol::FailoverConfig* Arena::CreateMaybeMessage<::trafficcontrol::FailoverConfig>(Arena*);
template<> ::trafficcontrol::Locality* Arena::CreateMaybeMessage<::trafficcontrol::Locality>(Arena*);
template<> ::trafficcontrol::LocalityRoutingConfig* Arena::CreateMaybeMessage<::trafficcontrol::LocalityRoutingConfig>(Arena*);
template<> ::trafficcontrol::MatchString* Arena::CreateMaybeMessage<::trafficcontrol::MatchString>(Arena*);
template<> ::trafficcontrol::MetadataRoutingConfig* Arena::CreateMaybeMessage<::trafficcontrol::MetadataRoutingConfig>(Arena*);
template<> ::trafficcontrol::Route* Arena::CreateMaybeMessage<::trafficcontrol::Route>(Arena*);
template<> ::trafficcontrol::Router* Arena::CreateMaybeMessage<::trafficcontrol::Router>(Arena*);
template<> ::trafficcontrol::Routing* Arena::CreateMaybeMessage<::trafficcontrol::Routing>(Arena*);
template<> ::trafficcontrol::RuleRoutingConfig* Arena::CreateMaybeMessage<::trafficcontrol::RuleRoutingConfig>(Arena*);
template<> ::trafficcontrol::Source* Arena::CreateMaybeMessage<::trafficcontrol::Source>(Arena*);
template<> ::trafficcontrol::Source_MetadataEntry_DoNotUse* Arena::CreateMaybeMessage<::trafficcontrol::Source_MetadataEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace trafficcontrol {

enum MatchString_MatchStringType : int {
  MatchString_MatchStringType_EXACT = 0,
  MatchString_MatchStringType_REGEX = 1,
  MatchString_MatchStringType_NOT_EQUALS = 2,
  MatchString_MatchStringType_INCLUDE = 3,
  MatchString_MatchStringType_NOT_INCLUDE = 4,
  MatchString_MatchStringType_MatchString_MatchStringType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchString_MatchStringType_MatchString_MatchStringType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchString_MatchStringType_IsValid(int value);
constexpr MatchString_MatchStringType MatchString_MatchStringType_MatchStringType_MIN = MatchString_MatchStringType_EXACT;
constexpr MatchString_MatchStringType MatchString_MatchStringType_MatchStringType_MAX = MatchString_MatchStringType_NOT_INCLUDE;
constexpr int MatchString_MatchStringType_MatchStringType_ARRAYSIZE = MatchString_MatchStringType_MatchStringType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchString_MatchStringType_descriptor();
template<typename T>
inline const std::string& MatchString_MatchStringType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchString_MatchStringType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchString_MatchStringType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchString_MatchStringType_descriptor(), enum_t_value);
}
inline bool MatchString_MatchStringType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchString_MatchStringType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchString_MatchStringType>(
    MatchString_MatchStringType_descriptor(), name, value);
}
enum MatchString_ValueType : int {
  MatchString_ValueType_TEXT = 0,
  MatchString_ValueType_PARAMETER = 1,
  MatchString_ValueType_VARIABLE = 2,
  MatchString_ValueType_MatchString_ValueType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MatchString_ValueType_MatchString_ValueType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MatchString_ValueType_IsValid(int value);
constexpr MatchString_ValueType MatchString_ValueType_ValueType_MIN = MatchString_ValueType_TEXT;
constexpr MatchString_ValueType MatchString_ValueType_ValueType_MAX = MatchString_ValueType_VARIABLE;
constexpr int MatchString_ValueType_ValueType_ARRAYSIZE = MatchString_ValueType_ValueType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MatchString_ValueType_descriptor();
template<typename T>
inline const std::string& MatchString_ValueType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MatchString_ValueType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MatchString_ValueType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MatchString_ValueType_descriptor(), enum_t_value);
}
inline bool MatchString_ValueType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MatchString_ValueType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MatchString_ValueType>(
    MatchString_ValueType_descriptor(), name, value);
}
enum LocalityRoutingConfig_LocalityLevel : int {
  LocalityRoutingConfig_LocalityLevel_CAMPUS = 0,
  LocalityRoutingConfig_LocalityLevel_ZONE = 1,
  LocalityRoutingConfig_LocalityLevel_REGION = 2,
  LocalityRoutingConfig_LocalityLevel_ALL = 3,
  LocalityRoutingConfig_LocalityLevel_LocalityRoutingConfig_LocalityLevel_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  LocalityRoutingConfig_LocalityLevel_LocalityRoutingConfig_LocalityLevel_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool LocalityRoutingConfig_LocalityLevel_IsValid(int value);
constexpr LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig_LocalityLevel_LocalityLevel_MIN = LocalityRoutingConfig_LocalityLevel_CAMPUS;
constexpr LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig_LocalityLevel_LocalityLevel_MAX = LocalityRoutingConfig_LocalityLevel_ALL;
constexpr int LocalityRoutingConfig_LocalityLevel_LocalityLevel_ARRAYSIZE = LocalityRoutingConfig_LocalityLevel_LocalityLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* LocalityRoutingConfig_LocalityLevel_descriptor();
template<typename T>
inline const std::string& LocalityRoutingConfig_LocalityLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, LocalityRoutingConfig_LocalityLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function LocalityRoutingConfig_LocalityLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    LocalityRoutingConfig_LocalityLevel_descriptor(), enum_t_value);
}
inline bool LocalityRoutingConfig_LocalityLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, LocalityRoutingConfig_LocalityLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<LocalityRoutingConfig_LocalityLevel>(
    LocalityRoutingConfig_LocalityLevel_descriptor(), name, value);
}
enum MetadataRoutingConfig_FailoverRange : int {
  MetadataRoutingConfig_FailoverRange_ALL = 0,
  MetadataRoutingConfig_FailoverRange_OTHERS = 1,
  MetadataRoutingConfig_FailoverRange_OTHER_KEYS = 2,
  MetadataRoutingConfig_FailoverRange_MetadataRoutingConfig_FailoverRange_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MetadataRoutingConfig_FailoverRange_MetadataRoutingConfig_FailoverRange_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MetadataRoutingConfig_FailoverRange_IsValid(int value);
constexpr MetadataRoutingConfig_FailoverRange MetadataRoutingConfig_FailoverRange_FailoverRange_MIN = MetadataRoutingConfig_FailoverRange_ALL;
constexpr MetadataRoutingConfig_FailoverRange MetadataRoutingConfig_FailoverRange_FailoverRange_MAX = MetadataRoutingConfig_FailoverRange_OTHER_KEYS;
constexpr int MetadataRoutingConfig_FailoverRange_FailoverRange_ARRAYSIZE = MetadataRoutingConfig_FailoverRange_FailoverRange_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MetadataRoutingConfig_FailoverRange_descriptor();
template<typename T>
inline const std::string& MetadataRoutingConfig_FailoverRange_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MetadataRoutingConfig_FailoverRange>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MetadataRoutingConfig_FailoverRange_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MetadataRoutingConfig_FailoverRange_descriptor(), enum_t_value);
}
inline bool MetadataRoutingConfig_FailoverRange_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MetadataRoutingConfig_FailoverRange* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MetadataRoutingConfig_FailoverRange>(
    MetadataRoutingConfig_FailoverRange_descriptor(), name, value);
}
enum RoutingPolicy : int {
  RulePolicy = 0,
  MetadataPolicy = 1,
  LocalityPolicy = 2,
  RoutingPolicy_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RoutingPolicy_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RoutingPolicy_IsValid(int value);
constexpr RoutingPolicy RoutingPolicy_MIN = RulePolicy;
constexpr RoutingPolicy RoutingPolicy_MAX = LocalityPolicy;
constexpr int RoutingPolicy_ARRAYSIZE = RoutingPolicy_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RoutingPolicy_descriptor();
template<typename T>
inline const std::string& RoutingPolicy_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RoutingPolicy>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RoutingPolicy_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RoutingPolicy_descriptor(), enum_t_value);
}
inline bool RoutingPolicy_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RoutingPolicy* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RoutingPolicy>(
    RoutingPolicy_descriptor(), name, value);
}
// ===================================================================

class Routing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Routing) */ {
 public:
  inline Routing() : Routing(nullptr) {}
  ~Routing() override;
  explicit PROTOBUF_CONSTEXPR Routing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Routing(const Routing& from);
  Routing(Routing&& from) noexcept
    : Routing() {
    *this = ::std::move(from);
  }

  inline Routing& operator=(const Routing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Routing& operator=(Routing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Routing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Routing* internal_default_instance() {
    return reinterpret_cast<const Routing*>(
               &_Routing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Routing& a, Routing& b) {
    a.Swap(&b);
  }
  inline void Swap(Routing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Routing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Routing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Routing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Routing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Routing& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Routing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Routing";
  }
  protected:
  explicit Routing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInboundsFieldNumber = 3,
    kOutboundsFieldNumber = 4,
    kRoutersFieldNumber = 10,
    kNamespaceFieldNumber = 1,
    kServiceFieldNumber = 2,
    kCtimeFieldNumber = 5,
    kMtimeFieldNumber = 6,
    kRevisionFieldNumber = 7,
    kServiceTokenFieldNumber = 8,
    kIdFieldNumber = 9,
    kFailoverFieldNumber = 11,
  };
  // repeated .trafficcontrol.Route inbounds = 3;
  int inbounds_size() const;
  private:
  int _internal_inbounds_size() const;
  public:
  void clear_inbounds();
  ::trafficcontrol::Route* mutable_inbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_inbounds();
  private:
  const ::trafficcontrol::Route& _internal_inbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_inbounds();
  public:
  const ::trafficcontrol::Route& inbounds(int index) const;
  ::trafficcontrol::Route* add_inbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      inbounds() const;

  // repeated .trafficcontrol.Route outbounds = 4;
  int outbounds_size() const;
  private:
  int _internal_outbounds_size() const;
  public:
  void clear_outbounds();
  ::trafficcontrol::Route* mutable_outbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_outbounds();
  private:
  const ::trafficcontrol::Route& _internal_outbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_outbounds();
  public:
  const ::trafficcontrol::Route& outbounds(int index) const;
  ::trafficcontrol::Route* add_outbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      outbounds() const;

  // repeated .trafficcontrol.Router routers = 10;
  int routers_size() const;
  private:
  int _internal_routers_size() const;
  public:
  void clear_routers();
  ::trafficcontrol::Router* mutable_routers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >*
      mutable_routers();
  private:
  const ::trafficcontrol::Router& _internal_routers(int index) const;
  ::trafficcontrol::Router* _internal_add_routers();
  public:
  const ::trafficcontrol::Router& routers(int index) const;
  ::trafficcontrol::Router* add_routers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >&
      routers() const;

  // .google.protobuf.StringValue namespace = 1;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .google.protobuf.StringValue service = 2;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .google.protobuf.StringValue ctime = 5;
  bool has_ctime() const;
  private:
  bool _internal_has_ctime() const;
  public:
  void clear_ctime();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& ctime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_ctime();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_ctime();
  void set_allocated_ctime(::PROTOBUF_NAMESPACE_ID::StringValue* ctime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_ctime() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_ctime();
  public:
  void unsafe_arena_set_allocated_ctime(
      ::PROTOBUF_NAMESPACE_ID::StringValue* ctime);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_ctime();

  // .google.protobuf.StringValue mtime = 6;
  bool has_mtime() const;
  private:
  bool _internal_has_mtime() const;
  public:
  void clear_mtime();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& mtime() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_mtime();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_mtime();
  void set_allocated_mtime(::PROTOBUF_NAMESPACE_ID::StringValue* mtime);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_mtime() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_mtime();
  public:
  void unsafe_arena_set_allocated_mtime(
      ::PROTOBUF_NAMESPACE_ID::StringValue* mtime);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_mtime();

  // .google.protobuf.StringValue revision = 7;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& revision() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_revision();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_revision();
  void set_allocated_revision(::PROTOBUF_NAMESPACE_ID::StringValue* revision);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_revision() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_revision();
  public:
  void unsafe_arena_set_allocated_revision(
      ::PROTOBUF_NAMESPACE_ID::StringValue* revision);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_revision();

  // .google.protobuf.StringValue service_token = 8 [json_name = "service_token"];
  bool has_service_token() const;
  private:
  bool _internal_has_service_token() const;
  public:
  void clear_service_token();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service_token() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service_token();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service_token();
  void set_allocated_service_token(::PROTOBUF_NAMESPACE_ID::StringValue* service_token);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service_token() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service_token();
  public:
  void unsafe_arena_set_allocated_service_token(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service_token);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service_token();

  // .google.protobuf.StringValue id = 9;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& id() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_id();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_id();
  void set_allocated_id(::PROTOBUF_NAMESPACE_ID::StringValue* id);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_id() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_id();
  public:
  void unsafe_arena_set_allocated_id(
      ::PROTOBUF_NAMESPACE_ID::StringValue* id);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_id();

  // .trafficcontrol.FailoverConfig failover = 11;
  bool has_failover() const;
  private:
  bool _internal_has_failover() const;
  public:
  void clear_failover();
  const ::trafficcontrol::FailoverConfig& failover() const;
  PROTOBUF_NODISCARD ::trafficcontrol::FailoverConfig* release_failover();
  ::trafficcontrol::FailoverConfig* mutable_failover();
  void set_allocated_failover(::trafficcontrol::FailoverConfig* failover);
  private:
  const ::trafficcontrol::FailoverConfig& _internal_failover() const;
  ::trafficcontrol::FailoverConfig* _internal_mutable_failover();
  public:
  void unsafe_arena_set_allocated_failover(
      ::trafficcontrol::FailoverConfig* failover);
  ::trafficcontrol::FailoverConfig* unsafe_arena_release_failover();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Routing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > inbounds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > outbounds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router > routers_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* ctime_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* mtime_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* revision_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_token_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* id_;
  ::trafficcontrol::FailoverConfig* failover_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Router final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Router) */ {
 public:
  inline Router() : Router(nullptr) {}
  ~Router() override;
  explicit PROTOBUF_CONSTEXPR Router(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Router(const Router& from);
  Router(Router&& from) noexcept
    : Router() {
    *this = ::std::move(from);
  }

  inline Router& operator=(const Router& from) {
    CopyFrom(from);
    return *this;
  }
  inline Router& operator=(Router&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Router& default_instance() {
    return *internal_default_instance();
  }
  static inline const Router* internal_default_instance() {
    return reinterpret_cast<const Router*>(
               &_Router_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Router& a, Router& b) {
    a.Swap(&b);
  }
  inline void Swap(Router* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Router* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Router* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Router>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Router& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Router& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Router* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Router";
  }
  protected:
  explicit Router(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
    kRoutingConfigFieldNumber = 3,
    kRoutingPolicyFieldNumber = 2,
  };
  // .google.protobuf.BoolValue enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& enable() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_enable();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_enable();
  void set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_enable() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_enable();
  public:
  void unsafe_arena_set_allocated_enable(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_enable();

  // .google.protobuf.Any routing_config = 3;
  bool has_routing_config() const;
  private:
  bool _internal_has_routing_config() const;
  public:
  void clear_routing_config();
  const ::PROTOBUF_NAMESPACE_ID::Any& routing_config() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::Any* release_routing_config();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_routing_config();
  void set_allocated_routing_config(::PROTOBUF_NAMESPACE_ID::Any* routing_config);
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_routing_config() const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_mutable_routing_config();
  public:
  void unsafe_arena_set_allocated_routing_config(
      ::PROTOBUF_NAMESPACE_ID::Any* routing_config);
  ::PROTOBUF_NAMESPACE_ID::Any* unsafe_arena_release_routing_config();

  // .trafficcontrol.RoutingPolicy routing_policy = 2;
  void clear_routing_policy();
  ::trafficcontrol::RoutingPolicy routing_policy() const;
  void set_routing_policy(::trafficcontrol::RoutingPolicy value);
  private:
  ::trafficcontrol::RoutingPolicy _internal_routing_policy() const;
  void _internal_set_routing_policy(::trafficcontrol::RoutingPolicy value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.Router)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_;
  ::PROTOBUF_NAMESPACE_ID::Any* routing_config_;
  int routing_policy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class MatchString final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.MatchString) */ {
 public:
  inline MatchString() : MatchString(nullptr) {}
  ~MatchString() override;
  explicit PROTOBUF_CONSTEXPR MatchString(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MatchString(const MatchString& from);
  MatchString(MatchString&& from) noexcept
    : MatchString() {
    *this = ::std::move(from);
  }

  inline MatchString& operator=(const MatchString& from) {
    CopyFrom(from);
    return *this;
  }
  inline MatchString& operator=(MatchString&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MatchString& default_instance() {
    return *internal_default_instance();
  }
  static inline const MatchString* internal_default_instance() {
    return reinterpret_cast<const MatchString*>(
               &_MatchString_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(MatchString& a, MatchString& b) {
    a.Swap(&b);
  }
  inline void Swap(MatchString* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MatchString* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MatchString* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MatchString>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MatchString& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MatchString& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MatchString* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.MatchString";
  }
  protected:
  explicit MatchString(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MatchString_MatchStringType MatchStringType;
  static constexpr MatchStringType EXACT =
    MatchString_MatchStringType_EXACT;
  static constexpr MatchStringType REGEX =
    MatchString_MatchStringType_REGEX;
  static constexpr MatchStringType NOT_EQUALS =
    MatchString_MatchStringType_NOT_EQUALS;
  static constexpr MatchStringType INCLUDE =
    MatchString_MatchStringType_INCLUDE;
  static constexpr MatchStringType NOT_INCLUDE =
    MatchString_MatchStringType_NOT_INCLUDE;
  static inline bool MatchStringType_IsValid(int value) {
    return MatchString_MatchStringType_IsValid(value);
  }
  static constexpr MatchStringType MatchStringType_MIN =
    MatchString_MatchStringType_MatchStringType_MIN;
  static constexpr MatchStringType MatchStringType_MAX =
    MatchString_MatchStringType_MatchStringType_MAX;
  static constexpr int MatchStringType_ARRAYSIZE =
    MatchString_MatchStringType_MatchStringType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MatchStringType_descriptor() {
    return MatchString_MatchStringType_descriptor();
  }
  template<typename T>
  static inline const std::string& MatchStringType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MatchStringType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MatchStringType_Name.");
    return MatchString_MatchStringType_Name(enum_t_value);
  }
  static inline bool MatchStringType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MatchStringType* value) {
    return MatchString_MatchStringType_Parse(name, value);
  }

  typedef MatchString_ValueType ValueType;
  static constexpr ValueType TEXT =
    MatchString_ValueType_TEXT;
  static constexpr ValueType PARAMETER =
    MatchString_ValueType_PARAMETER;
  static constexpr ValueType VARIABLE =
    MatchString_ValueType_VARIABLE;
  static inline bool ValueType_IsValid(int value) {
    return MatchString_ValueType_IsValid(value);
  }
  static constexpr ValueType ValueType_MIN =
    MatchString_ValueType_ValueType_MIN;
  static constexpr ValueType ValueType_MAX =
    MatchString_ValueType_ValueType_MAX;
  static constexpr int ValueType_ARRAYSIZE =
    MatchString_ValueType_ValueType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ValueType_descriptor() {
    return MatchString_ValueType_descriptor();
  }
  template<typename T>
  static inline const std::string& ValueType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ValueType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ValueType_Name.");
    return MatchString_ValueType_Name(enum_t_value);
  }
  static inline bool ValueType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ValueType* value) {
    return MatchString_ValueType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 2,
    kTypeFieldNumber = 1,
    kValueTypeFieldNumber = 3,
  };
  // .google.protobuf.StringValue value = 2;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& value() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_value();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_value();
  void set_allocated_value(::PROTOBUF_NAMESPACE_ID::StringValue* value);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_value() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_value();
  public:
  void unsafe_arena_set_allocated_value(
      ::PROTOBUF_NAMESPACE_ID::StringValue* value);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_value();

  // .trafficcontrol.MatchString.MatchStringType type = 1;
  void clear_type();
  ::trafficcontrol::MatchString_MatchStringType type() const;
  void set_type(::trafficcontrol::MatchString_MatchStringType value);
  private:
  ::trafficcontrol::MatchString_MatchStringType _internal_type() const;
  void _internal_set_type(::trafficcontrol::MatchString_MatchStringType value);
  public:

  // .trafficcontrol.MatchString.ValueType value_type = 3;
  void clear_value_type();
  ::trafficcontrol::MatchString_ValueType value_type() const;
  void set_value_type(::trafficcontrol::MatchString_ValueType value);
  private:
  ::trafficcontrol::MatchString_ValueType _internal_value_type() const;
  void _internal_set_value_type(::trafficcontrol::MatchString_ValueType value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.MatchString)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* value_;
  int type_;
  int value_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Locality final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Locality) */ {
 public:
  inline Locality() : Locality(nullptr) {}
  ~Locality() override;
  explicit PROTOBUF_CONSTEXPR Locality(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Locality(const Locality& from);
  Locality(Locality&& from) noexcept
    : Locality() {
    *this = ::std::move(from);
  }

  inline Locality& operator=(const Locality& from) {
    CopyFrom(from);
    return *this;
  }
  inline Locality& operator=(Locality&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Locality& default_instance() {
    return *internal_default_instance();
  }
  static inline const Locality* internal_default_instance() {
    return reinterpret_cast<const Locality*>(
               &_Locality_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Locality& a, Locality& b) {
    a.Swap(&b);
  }
  inline void Swap(Locality* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Locality* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Locality* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Locality>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Locality& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Locality& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Locality* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Locality";
  }
  protected:
  explicit Locality(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegionFieldNumber = 1,
    kZoneFieldNumber = 2,
    kCampusFieldNumber = 3,
  };
  // .trafficcontrol.MatchString region = 1;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const ::trafficcontrol::MatchString& region() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_region();
  ::trafficcontrol::MatchString* mutable_region();
  void set_allocated_region(::trafficcontrol::MatchString* region);
  private:
  const ::trafficcontrol::MatchString& _internal_region() const;
  ::trafficcontrol::MatchString* _internal_mutable_region();
  public:
  void unsafe_arena_set_allocated_region(
      ::trafficcontrol::MatchString* region);
  ::trafficcontrol::MatchString* unsafe_arena_release_region();

  // .trafficcontrol.MatchString zone = 2;
  bool has_zone() const;
  private:
  bool _internal_has_zone() const;
  public:
  void clear_zone();
  const ::trafficcontrol::MatchString& zone() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_zone();
  ::trafficcontrol::MatchString* mutable_zone();
  void set_allocated_zone(::trafficcontrol::MatchString* zone);
  private:
  const ::trafficcontrol::MatchString& _internal_zone() const;
  ::trafficcontrol::MatchString* _internal_mutable_zone();
  public:
  void unsafe_arena_set_allocated_zone(
      ::trafficcontrol::MatchString* zone);
  ::trafficcontrol::MatchString* unsafe_arena_release_zone();

  // .trafficcontrol.MatchString campus = 3;
  bool has_campus() const;
  private:
  bool _internal_has_campus() const;
  public:
  void clear_campus();
  const ::trafficcontrol::MatchString& campus() const;
  PROTOBUF_NODISCARD ::trafficcontrol::MatchString* release_campus();
  ::trafficcontrol::MatchString* mutable_campus();
  void set_allocated_campus(::trafficcontrol::MatchString* campus);
  private:
  const ::trafficcontrol::MatchString& _internal_campus() const;
  ::trafficcontrol::MatchString* _internal_mutable_campus();
  public:
  void unsafe_arena_set_allocated_campus(
      ::trafficcontrol::MatchString* campus);
  ::trafficcontrol::MatchString* unsafe_arena_release_campus();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Locality)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::trafficcontrol::MatchString* region_;
  ::trafficcontrol::MatchString* zone_;
  ::trafficcontrol::MatchString* campus_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class FailoverConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.FailoverConfig) */ {
 public:
  inline FailoverConfig() : FailoverConfig(nullptr) {}
  ~FailoverConfig() override;
  explicit PROTOBUF_CONSTEXPR FailoverConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailoverConfig(const FailoverConfig& from);
  FailoverConfig(FailoverConfig&& from) noexcept
    : FailoverConfig() {
    *this = ::std::move(from);
  }

  inline FailoverConfig& operator=(const FailoverConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailoverConfig& operator=(FailoverConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailoverConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailoverConfig* internal_default_instance() {
    return reinterpret_cast<const FailoverConfig*>(
               &_FailoverConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FailoverConfig& a, FailoverConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FailoverConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailoverConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailoverConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailoverConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailoverConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FailoverConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailoverConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.FailoverConfig";
  }
  protected:
  explicit FailoverConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnableFieldNumber = 1,
    kTotalCountFieldNumber = 2,
    kHealthyCountFieldNumber = 3,
    kHealthyPercentFieldNumber = 4,
  };
  // .google.protobuf.BoolValue enable = 1;
  bool has_enable() const;
  private:
  bool _internal_has_enable() const;
  public:
  void clear_enable();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& enable() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_enable();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_enable();
  void set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_enable() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_enable();
  public:
  void unsafe_arena_set_allocated_enable(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* enable);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_enable();

  // .google.protobuf.UInt32Value total_count = 2;
  bool has_total_count() const;
  private:
  bool _internal_has_total_count() const;
  public:
  void clear_total_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& total_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_total_count();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_total_count();
  void set_allocated_total_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_total_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_total_count();
  public:
  void unsafe_arena_set_allocated_total_count(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_total_count();

  // .google.protobuf.UInt32Value healthy_count = 3;
  bool has_healthy_count() const;
  private:
  bool _internal_has_healthy_count() const;
  public:
  void clear_healthy_count();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& healthy_count() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_healthy_count();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_healthy_count();
  void set_allocated_healthy_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_healthy_count() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_healthy_count();
  public:
  void unsafe_arena_set_allocated_healthy_count(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_healthy_count();

  // .google.protobuf.UInt32Value healthy_percent = 4;
  bool has_healthy_percent() const;
  private:
  bool _internal_has_healthy_percent() const;
  public:
  void clear_healthy_percent();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& healthy_percent() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_healthy_percent();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_healthy_percent();
  void set_allocated_healthy_percent(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_healthy_percent() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_healthy_percent();
  public:
  void unsafe_arena_set_allocated_healthy_percent(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_healthy_percent();

  // @@protoc_insertion_point(class_scope:trafficcontrol.FailoverConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* enable_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class RuleRoutingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.RuleRoutingConfig) */ {
 public:
  inline RuleRoutingConfig() : RuleRoutingConfig(nullptr) {}
  ~RuleRoutingConfig() override;
  explicit PROTOBUF_CONSTEXPR RuleRoutingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RuleRoutingConfig(const RuleRoutingConfig& from);
  RuleRoutingConfig(RuleRoutingConfig&& from) noexcept
    : RuleRoutingConfig() {
    *this = ::std::move(from);
  }

  inline RuleRoutingConfig& operator=(const RuleRoutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline RuleRoutingConfig& operator=(RuleRoutingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RuleRoutingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const RuleRoutingConfig* internal_default_instance() {
    return reinterpret_cast<const RuleRoutingConfig*>(
               &_RuleRoutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RuleRoutingConfig& a, RuleRoutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(RuleRoutingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RuleRoutingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RuleRoutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RuleRoutingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RuleRoutingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RuleRoutingConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RuleRoutingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.RuleRoutingConfig";
  }
  protected:
  explicit RuleRoutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInboundsFieldNumber = 1,
    kOutboundsFieldNumber = 2,
  };
  // repeated .trafficcontrol.Route inbounds = 1;
  int inbounds_size() const;
  private:
  int _internal_inbounds_size() const;
  public:
  void clear_inbounds();
  ::trafficcontrol::Route* mutable_inbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_inbounds();
  private:
  const ::trafficcontrol::Route& _internal_inbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_inbounds();
  public:
  const ::trafficcontrol::Route& inbounds(int index) const;
  ::trafficcontrol::Route* add_inbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      inbounds() const;

  // repeated .trafficcontrol.Route outbounds = 2;
  int outbounds_size() const;
  private:
  int _internal_outbounds_size() const;
  public:
  void clear_outbounds();
  ::trafficcontrol::Route* mutable_outbounds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
      mutable_outbounds();
  private:
  const ::trafficcontrol::Route& _internal_outbounds(int index) const;
  ::trafficcontrol::Route* _internal_add_outbounds();
  public:
  const ::trafficcontrol::Route& outbounds(int index) const;
  ::trafficcontrol::Route* add_outbounds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
      outbounds() const;

  // @@protoc_insertion_point(class_scope:trafficcontrol.RuleRoutingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > inbounds_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route > outbounds_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Route final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Route) */ {
 public:
  inline Route() : Route(nullptr) {}
  ~Route() override;
  explicit PROTOBUF_CONSTEXPR Route(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Route(const Route& from);
  Route(Route&& from) noexcept
    : Route() {
    *this = ::std::move(from);
  }

  inline Route& operator=(const Route& from) {
    CopyFrom(from);
    return *this;
  }
  inline Route& operator=(Route&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Route& default_instance() {
    return *internal_default_instance();
  }
  static inline const Route* internal_default_instance() {
    return reinterpret_cast<const Route*>(
               &_Route_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Route& a, Route& b) {
    a.Swap(&b);
  }
  inline void Swap(Route* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Route* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Route* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Route>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Route& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Route& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Route* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Route";
  }
  protected:
  explicit Route(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourcesFieldNumber = 1,
    kDestinationsFieldNumber = 2,
  };
  // repeated .trafficcontrol.Source sources = 1;
  int sources_size() const;
  private:
  int _internal_sources_size() const;
  public:
  void clear_sources();
  ::trafficcontrol::Source* mutable_sources(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >*
      mutable_sources();
  private:
  const ::trafficcontrol::Source& _internal_sources(int index) const;
  ::trafficcontrol::Source* _internal_add_sources();
  public:
  const ::trafficcontrol::Source& sources(int index) const;
  ::trafficcontrol::Source* add_sources();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >&
      sources() const;

  // repeated .trafficcontrol.Destination destinations = 2;
  int destinations_size() const;
  private:
  int _internal_destinations_size() const;
  public:
  void clear_destinations();
  ::trafficcontrol::Destination* mutable_destinations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >*
      mutable_destinations();
  private:
  const ::trafficcontrol::Destination& _internal_destinations(int index) const;
  ::trafficcontrol::Destination* _internal_add_destinations();
  public:
  const ::trafficcontrol::Destination& destinations(int index) const;
  ::trafficcontrol::Destination* add_destinations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >&
      destinations() const;

  // @@protoc_insertion_point(class_scope:trafficcontrol.Route)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source > sources_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination > destinations_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Source_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Source_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Source_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Source_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Source_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Source_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Source_MetadataEntry_DoNotUse& other);
  static const Source_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Source_MetadataEntry_DoNotUse*>(&_Source_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "trafficcontrol.Source.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_2eproto;
};

// -------------------------------------------------------------------

class Source final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  ~Source() override;
  explicit PROTOBUF_CONSTEXPR Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Source& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Source& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kServiceFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kLocalityFieldNumber = 4,
  };
  // map<string, .trafficcontrol.MatchString> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      mutable_metadata();

  // .google.protobuf.StringValue service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .google.protobuf.StringValue namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .trafficcontrol.Locality locality = 4;
  bool has_locality() const;
  private:
  bool _internal_has_locality() const;
  public:
  void clear_locality();
  const ::trafficcontrol::Locality& locality() const;
  PROTOBUF_NODISCARD ::trafficcontrol::Locality* release_locality();
  ::trafficcontrol::Locality* mutable_locality();
  void set_allocated_locality(::trafficcontrol::Locality* locality);
  private:
  const ::trafficcontrol::Locality& _internal_locality() const;
  ::trafficcontrol::Locality* _internal_mutable_locality();
  public:
  void unsafe_arena_set_allocated_locality(
      ::trafficcontrol::Locality* locality);
  ::trafficcontrol::Locality* unsafe_arena_release_locality();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Source_MetadataEntry_DoNotUse,
      std::string, ::trafficcontrol::MatchString,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metadata_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::trafficcontrol::Locality* locality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class Destination_MetadataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Destination_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Destination_MetadataEntry_DoNotUse, 
    std::string, ::trafficcontrol::MatchString,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  Destination_MetadataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR Destination_MetadataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Destination_MetadataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Destination_MetadataEntry_DoNotUse& other);
  static const Destination_MetadataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Destination_MetadataEntry_DoNotUse*>(&_Destination_MetadataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "trafficcontrol.Destination.MetadataEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_router_2eproto;
};

// -------------------------------------------------------------------

class Destination final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.Destination) */ {
 public:
  inline Destination() : Destination(nullptr) {}
  ~Destination() override;
  explicit PROTOBUF_CONSTEXPR Destination(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Destination(const Destination& from);
  Destination(Destination&& from) noexcept
    : Destination() {
    *this = ::std::move(from);
  }

  inline Destination& operator=(const Destination& from) {
    CopyFrom(from);
    return *this;
  }
  inline Destination& operator=(Destination&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Destination& default_instance() {
    return *internal_default_instance();
  }
  static inline const Destination* internal_default_instance() {
    return reinterpret_cast<const Destination*>(
               &_Destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Destination& a, Destination& b) {
    a.Swap(&b);
  }
  inline void Swap(Destination* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Destination* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Destination* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Destination>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Destination& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Destination& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Destination* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.Destination";
  }
  protected:
  explicit Destination(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMetadataFieldNumber = 3,
    kServiceFieldNumber = 1,
    kNamespaceFieldNumber = 2,
    kPriorityFieldNumber = 4,
    kWeightFieldNumber = 5,
    kTransferFieldNumber = 6,
    kIsolateFieldNumber = 7,
    kLocalityFieldNumber = 8,
  };
  // map<string, .trafficcontrol.MatchString> metadata = 3;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      _internal_metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      _internal_mutable_metadata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
      metadata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
      mutable_metadata();

  // .google.protobuf.StringValue service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& service() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_service();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_service();
  void set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_service() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::PROTOBUF_NAMESPACE_ID::StringValue* service);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_service();

  // .google.protobuf.StringValue namespace = 2;
  bool has_namespace_() const;
  private:
  bool _internal_has_namespace_() const;
  public:
  void clear_namespace_();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& namespace_() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_namespace_();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_namespace_();
  void set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_namespace_() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_namespace_();
  public:
  void unsafe_arena_set_allocated_namespace_(
      ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_namespace_();

  // .google.protobuf.UInt32Value priority = 4;
  bool has_priority() const;
  private:
  bool _internal_has_priority() const;
  public:
  void clear_priority();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& priority() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_priority();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_priority();
  void set_allocated_priority(::PROTOBUF_NAMESPACE_ID::UInt32Value* priority);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_priority() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_priority();
  public:
  void unsafe_arena_set_allocated_priority(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_priority();

  // .google.protobuf.UInt32Value weight = 5;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& weight() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::UInt32Value* release_weight();
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* mutable_weight();
  void set_allocated_weight(::PROTOBUF_NAMESPACE_ID::UInt32Value* weight);
  private:
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value& _internal_weight() const;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _internal_mutable_weight();
  public:
  void unsafe_arena_set_allocated_weight(
      ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight);
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* unsafe_arena_release_weight();

  // .google.protobuf.StringValue transfer = 6;
  bool has_transfer() const;
  private:
  bool _internal_has_transfer() const;
  public:
  void clear_transfer();
  const ::PROTOBUF_NAMESPACE_ID::StringValue& transfer() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::StringValue* release_transfer();
  ::PROTOBUF_NAMESPACE_ID::StringValue* mutable_transfer();
  void set_allocated_transfer(::PROTOBUF_NAMESPACE_ID::StringValue* transfer);
  private:
  const ::PROTOBUF_NAMESPACE_ID::StringValue& _internal_transfer() const;
  ::PROTOBUF_NAMESPACE_ID::StringValue* _internal_mutable_transfer();
  public:
  void unsafe_arena_set_allocated_transfer(
      ::PROTOBUF_NAMESPACE_ID::StringValue* transfer);
  ::PROTOBUF_NAMESPACE_ID::StringValue* unsafe_arena_release_transfer();

  // .google.protobuf.BoolValue isolate = 7;
  bool has_isolate() const;
  private:
  bool _internal_has_isolate() const;
  public:
  void clear_isolate();
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& isolate() const;
  PROTOBUF_NODISCARD ::PROTOBUF_NAMESPACE_ID::BoolValue* release_isolate();
  ::PROTOBUF_NAMESPACE_ID::BoolValue* mutable_isolate();
  void set_allocated_isolate(::PROTOBUF_NAMESPACE_ID::BoolValue* isolate);
  private:
  const ::PROTOBUF_NAMESPACE_ID::BoolValue& _internal_isolate() const;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_isolate();
  public:
  void unsafe_arena_set_allocated_isolate(
      ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate);
  ::PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_isolate();

  // .trafficcontrol.Locality locality = 8;
  bool has_locality() const;
  private:
  bool _internal_has_locality() const;
  public:
  void clear_locality();
  const ::trafficcontrol::Locality& locality() const;
  PROTOBUF_NODISCARD ::trafficcontrol::Locality* release_locality();
  ::trafficcontrol::Locality* mutable_locality();
  void set_allocated_locality(::trafficcontrol::Locality* locality);
  private:
  const ::trafficcontrol::Locality& _internal_locality() const;
  ::trafficcontrol::Locality* _internal_mutable_locality();
  public:
  void unsafe_arena_set_allocated_locality(
      ::trafficcontrol::Locality* locality);
  ::trafficcontrol::Locality* unsafe_arena_release_locality();

  // @@protoc_insertion_point(class_scope:trafficcontrol.Destination)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Destination_MetadataEntry_DoNotUse,
      std::string, ::trafficcontrol::MatchString,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> metadata_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* service_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* namespace__;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority_;
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight_;
  ::PROTOBUF_NAMESPACE_ID::StringValue* transfer_;
  ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate_;
  ::trafficcontrol::Locality* locality_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class LocalityRoutingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.LocalityRoutingConfig) */ {
 public:
  inline LocalityRoutingConfig() : LocalityRoutingConfig(nullptr) {}
  ~LocalityRoutingConfig() override;
  explicit PROTOBUF_CONSTEXPR LocalityRoutingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LocalityRoutingConfig(const LocalityRoutingConfig& from);
  LocalityRoutingConfig(LocalityRoutingConfig&& from) noexcept
    : LocalityRoutingConfig() {
    *this = ::std::move(from);
  }

  inline LocalityRoutingConfig& operator=(const LocalityRoutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline LocalityRoutingConfig& operator=(LocalityRoutingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LocalityRoutingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const LocalityRoutingConfig* internal_default_instance() {
    return reinterpret_cast<const LocalityRoutingConfig*>(
               &_LocalityRoutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(LocalityRoutingConfig& a, LocalityRoutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(LocalityRoutingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LocalityRoutingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LocalityRoutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LocalityRoutingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LocalityRoutingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LocalityRoutingConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocalityRoutingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.LocalityRoutingConfig";
  }
  protected:
  explicit LocalityRoutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LocalityRoutingConfig_LocalityLevel LocalityLevel;
  static constexpr LocalityLevel CAMPUS =
    LocalityRoutingConfig_LocalityLevel_CAMPUS;
  static constexpr LocalityLevel ZONE =
    LocalityRoutingConfig_LocalityLevel_ZONE;
  static constexpr LocalityLevel REGION =
    LocalityRoutingConfig_LocalityLevel_REGION;
  static constexpr LocalityLevel ALL =
    LocalityRoutingConfig_LocalityLevel_ALL;
  static inline bool LocalityLevel_IsValid(int value) {
    return LocalityRoutingConfig_LocalityLevel_IsValid(value);
  }
  static constexpr LocalityLevel LocalityLevel_MIN =
    LocalityRoutingConfig_LocalityLevel_LocalityLevel_MIN;
  static constexpr LocalityLevel LocalityLevel_MAX =
    LocalityRoutingConfig_LocalityLevel_LocalityLevel_MAX;
  static constexpr int LocalityLevel_ARRAYSIZE =
    LocalityRoutingConfig_LocalityLevel_LocalityLevel_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  LocalityLevel_descriptor() {
    return LocalityRoutingConfig_LocalityLevel_descriptor();
  }
  template<typename T>
  static inline const std::string& LocalityLevel_Name(T enum_t_value) {
    static_assert(::std::is_same<T, LocalityLevel>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function LocalityLevel_Name.");
    return LocalityRoutingConfig_LocalityLevel_Name(enum_t_value);
  }
  static inline bool LocalityLevel_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      LocalityLevel* value) {
    return LocalityRoutingConfig_LocalityLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLocalityLevelFieldNumber = 1,
    kMaxLocalityLevelFieldNumber = 2,
  };
  // .trafficcontrol.LocalityRoutingConfig.LocalityLevel locality_level = 1;
  void clear_locality_level();
  ::trafficcontrol::LocalityRoutingConfig_LocalityLevel locality_level() const;
  void set_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value);
  private:
  ::trafficcontrol::LocalityRoutingConfig_LocalityLevel _internal_locality_level() const;
  void _internal_set_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value);
  public:

  // .trafficcontrol.LocalityRoutingConfig.LocalityLevel max_locality_level = 2;
  void clear_max_locality_level();
  ::trafficcontrol::LocalityRoutingConfig_LocalityLevel max_locality_level() const;
  void set_max_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value);
  private:
  ::trafficcontrol::LocalityRoutingConfig_LocalityLevel _internal_max_locality_level() const;
  void _internal_set_max_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.LocalityRoutingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int locality_level_;
  int max_locality_level_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// -------------------------------------------------------------------

class MetadataRoutingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:trafficcontrol.MetadataRoutingConfig) */ {
 public:
  inline MetadataRoutingConfig() : MetadataRoutingConfig(nullptr) {}
  ~MetadataRoutingConfig() override;
  explicit PROTOBUF_CONSTEXPR MetadataRoutingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MetadataRoutingConfig(const MetadataRoutingConfig& from);
  MetadataRoutingConfig(MetadataRoutingConfig&& from) noexcept
    : MetadataRoutingConfig() {
    *this = ::std::move(from);
  }

  inline MetadataRoutingConfig& operator=(const MetadataRoutingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline MetadataRoutingConfig& operator=(MetadataRoutingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MetadataRoutingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const MetadataRoutingConfig* internal_default_instance() {
    return reinterpret_cast<const MetadataRoutingConfig*>(
               &_MetadataRoutingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(MetadataRoutingConfig& a, MetadataRoutingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(MetadataRoutingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MetadataRoutingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MetadataRoutingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MetadataRoutingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MetadataRoutingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MetadataRoutingConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetadataRoutingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "trafficcontrol.MetadataRoutingConfig";
  }
  protected:
  explicit MetadataRoutingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef MetadataRoutingConfig_FailoverRange FailoverRange;
  static constexpr FailoverRange ALL =
    MetadataRoutingConfig_FailoverRange_ALL;
  static constexpr FailoverRange OTHERS =
    MetadataRoutingConfig_FailoverRange_OTHERS;
  static constexpr FailoverRange OTHER_KEYS =
    MetadataRoutingConfig_FailoverRange_OTHER_KEYS;
  static inline bool FailoverRange_IsValid(int value) {
    return MetadataRoutingConfig_FailoverRange_IsValid(value);
  }
  static constexpr FailoverRange FailoverRange_MIN =
    MetadataRoutingConfig_FailoverRange_FailoverRange_MIN;
  static constexpr FailoverRange FailoverRange_MAX =
    MetadataRoutingConfig_FailoverRange_FailoverRange_MAX;
  static constexpr int FailoverRange_ARRAYSIZE =
    MetadataRoutingConfig_FailoverRange_FailoverRange_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FailoverRange_descriptor() {
    return MetadataRoutingConfig_FailoverRange_descriptor();
  }
  template<typename T>
  static inline const std::string& FailoverRange_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FailoverRange>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FailoverRange_Name.");
    return MetadataRoutingConfig_FailoverRange_Name(enum_t_value);
  }
  static inline bool FailoverRange_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FailoverRange* value) {
    return MetadataRoutingConfig_FailoverRange_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFailoverRangeFieldNumber = 1,
  };
  // .trafficcontrol.MetadataRoutingConfig.FailoverRange failover_range = 1;
  void clear_failover_range();
  ::trafficcontrol::MetadataRoutingConfig_FailoverRange failover_range() const;
  void set_failover_range(::trafficcontrol::MetadataRoutingConfig_FailoverRange value);
  private:
  ::trafficcontrol::MetadataRoutingConfig_FailoverRange _internal_failover_range() const;
  void _internal_set_failover_range(::trafficcontrol::MetadataRoutingConfig_FailoverRange value);
  public:

  // @@protoc_insertion_point(class_scope:trafficcontrol.MetadataRoutingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int failover_range_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_router_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Routing

// .google.protobuf.StringValue namespace = 1;
inline bool Routing::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Routing::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.namespace)
  return _internal_namespace_();
}
inline void Routing::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.namespace)
  return _msg;
}
inline void Routing::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.namespace)
}

// .google.protobuf.StringValue service = 2;
inline bool Routing::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool Routing::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.service)
  return _internal_service();
}
inline void Routing::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.service)
  return _msg;
}
inline void Routing::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.service)
}

// repeated .trafficcontrol.Route inbounds = 3;
inline int Routing::_internal_inbounds_size() const {
  return inbounds_.size();
}
inline int Routing::inbounds_size() const {
  return _internal_inbounds_size();
}
inline void Routing::clear_inbounds() {
  inbounds_.Clear();
}
inline ::trafficcontrol::Route* Routing::mutable_inbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.inbounds)
  return inbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
Routing::mutable_inbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Routing.inbounds)
  return &inbounds_;
}
inline const ::trafficcontrol::Route& Routing::_internal_inbounds(int index) const {
  return inbounds_.Get(index);
}
inline const ::trafficcontrol::Route& Routing::inbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.inbounds)
  return _internal_inbounds(index);
}
inline ::trafficcontrol::Route* Routing::_internal_add_inbounds() {
  return inbounds_.Add();
}
inline ::trafficcontrol::Route* Routing::add_inbounds() {
  ::trafficcontrol::Route* _add = _internal_add_inbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.Routing.inbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
Routing::inbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Routing.inbounds)
  return inbounds_;
}

// repeated .trafficcontrol.Route outbounds = 4;
inline int Routing::_internal_outbounds_size() const {
  return outbounds_.size();
}
inline int Routing::outbounds_size() const {
  return _internal_outbounds_size();
}
inline void Routing::clear_outbounds() {
  outbounds_.Clear();
}
inline ::trafficcontrol::Route* Routing::mutable_outbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.outbounds)
  return outbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
Routing::mutable_outbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Routing.outbounds)
  return &outbounds_;
}
inline const ::trafficcontrol::Route& Routing::_internal_outbounds(int index) const {
  return outbounds_.Get(index);
}
inline const ::trafficcontrol::Route& Routing::outbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.outbounds)
  return _internal_outbounds(index);
}
inline ::trafficcontrol::Route* Routing::_internal_add_outbounds() {
  return outbounds_.Add();
}
inline ::trafficcontrol::Route* Routing::add_outbounds() {
  ::trafficcontrol::Route* _add = _internal_add_outbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.Routing.outbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
Routing::outbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Routing.outbounds)
  return outbounds_;
}

// .google.protobuf.StringValue ctime = 5;
inline bool Routing::_internal_has_ctime() const {
  return this != internal_default_instance() && ctime_ != nullptr;
}
inline bool Routing::has_ctime() const {
  return _internal_has_ctime();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_ctime() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = ctime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::ctime() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.ctime)
  return _internal_ctime();
}
inline void Routing::unsafe_arena_set_allocated_ctime(
    ::PROTOBUF_NAMESPACE_ID::StringValue* ctime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ctime_);
  }
  ctime_ = ctime;
  if (ctime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.ctime)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_ctime() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = ctime_;
  ctime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_ctime() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.ctime)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = ctime_;
  ctime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_ctime() {
  
  if (ctime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    ctime_ = p;
  }
  return ctime_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_ctime() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_ctime();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.ctime)
  return _msg;
}
inline void Routing::set_allocated_ctime(::PROTOBUF_NAMESPACE_ID::StringValue* ctime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ctime_);
  }
  if (ctime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ctime));
    if (message_arena != submessage_arena) {
      ctime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ctime, submessage_arena);
    }
    
  } else {
    
  }
  ctime_ = ctime;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.ctime)
}

// .google.protobuf.StringValue mtime = 6;
inline bool Routing::_internal_has_mtime() const {
  return this != internal_default_instance() && mtime_ != nullptr;
}
inline bool Routing::has_mtime() const {
  return _internal_has_mtime();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_mtime() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = mtime_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::mtime() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.mtime)
  return _internal_mtime();
}
inline void Routing::unsafe_arena_set_allocated_mtime(
    ::PROTOBUF_NAMESPACE_ID::StringValue* mtime) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mtime_);
  }
  mtime_ = mtime;
  if (mtime) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.mtime)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_mtime() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = mtime_;
  mtime_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_mtime() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.mtime)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = mtime_;
  mtime_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_mtime() {
  
  if (mtime_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    mtime_ = p;
  }
  return mtime_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_mtime() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_mtime();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.mtime)
  return _msg;
}
inline void Routing::set_allocated_mtime(::PROTOBUF_NAMESPACE_ID::StringValue* mtime) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(mtime_);
  }
  if (mtime) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(mtime));
    if (message_arena != submessage_arena) {
      mtime = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mtime, submessage_arena);
    }
    
  } else {
    
  }
  mtime_ = mtime;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.mtime)
}

// .google.protobuf.StringValue revision = 7;
inline bool Routing::_internal_has_revision() const {
  return this != internal_default_instance() && revision_ != nullptr;
}
inline bool Routing::has_revision() const {
  return _internal_has_revision();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_revision() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = revision_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::revision() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.revision)
  return _internal_revision();
}
inline void Routing::unsafe_arena_set_allocated_revision(
    ::PROTOBUF_NAMESPACE_ID::StringValue* revision) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  revision_ = revision;
  if (revision) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.revision)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_revision() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = revision_;
  revision_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_revision() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.revision)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = revision_;
  revision_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_revision() {
  
  if (revision_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    revision_ = p;
  }
  return revision_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_revision() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_revision();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.revision)
  return _msg;
}
inline void Routing::set_allocated_revision(::PROTOBUF_NAMESPACE_ID::StringValue* revision) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision_);
  }
  if (revision) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(revision));
    if (message_arena != submessage_arena) {
      revision = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, revision, submessage_arena);
    }
    
  } else {
    
  }
  revision_ = revision;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.revision)
}

// .google.protobuf.StringValue service_token = 8 [json_name = "service_token"];
inline bool Routing::_internal_has_service_token() const {
  return this != internal_default_instance() && service_token_ != nullptr;
}
inline bool Routing::has_service_token() const {
  return _internal_has_service_token();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_service_token() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_token_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::service_token() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.service_token)
  return _internal_service_token();
}
inline void Routing::unsafe_arena_set_allocated_service_token(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service_token) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_token_);
  }
  service_token_ = service_token;
  if (service_token) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.service_token)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_service_token() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_token_;
  service_token_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_service_token() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.service_token)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_token_;
  service_token_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_service_token() {
  
  if (service_token_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_token_ = p;
  }
  return service_token_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_service_token() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service_token();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.service_token)
  return _msg;
}
inline void Routing::set_allocated_service_token(::PROTOBUF_NAMESPACE_ID::StringValue* service_token) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_token_);
  }
  if (service_token) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_token));
    if (message_arena != submessage_arena) {
      service_token = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service_token, submessage_arena);
    }
    
  } else {
    
  }
  service_token_ = service_token;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.service_token)
}

// .google.protobuf.StringValue id = 9;
inline bool Routing::_internal_has_id() const {
  return this != internal_default_instance() && id_ != nullptr;
}
inline bool Routing::has_id() const {
  return _internal_has_id();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::_internal_id() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = id_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Routing::id() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.id)
  return _internal_id();
}
inline void Routing::unsafe_arena_set_allocated_id(
    ::PROTOBUF_NAMESPACE_ID::StringValue* id) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  id_ = id;
  if (id) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.id)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::release_id() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = id_;
  id_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::unsafe_arena_release_id() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.id)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = id_;
  id_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::_internal_mutable_id() {
  
  if (id_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    id_ = p;
  }
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Routing::mutable_id() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.id)
  return _msg;
}
inline void Routing::set_allocated_id(::PROTOBUF_NAMESPACE_ID::StringValue* id) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(id_);
  }
  if (id) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(id));
    if (message_arena != submessage_arena) {
      id = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, id, submessage_arena);
    }
    
  } else {
    
  }
  id_ = id;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.id)
}

// repeated .trafficcontrol.Router routers = 10;
inline int Routing::_internal_routers_size() const {
  return routers_.size();
}
inline int Routing::routers_size() const {
  return _internal_routers_size();
}
inline void Routing::clear_routers() {
  routers_.Clear();
}
inline ::trafficcontrol::Router* Routing::mutable_routers(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.routers)
  return routers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >*
Routing::mutable_routers() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Routing.routers)
  return &routers_;
}
inline const ::trafficcontrol::Router& Routing::_internal_routers(int index) const {
  return routers_.Get(index);
}
inline const ::trafficcontrol::Router& Routing::routers(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.routers)
  return _internal_routers(index);
}
inline ::trafficcontrol::Router* Routing::_internal_add_routers() {
  return routers_.Add();
}
inline ::trafficcontrol::Router* Routing::add_routers() {
  ::trafficcontrol::Router* _add = _internal_add_routers();
  // @@protoc_insertion_point(field_add:trafficcontrol.Routing.routers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Router >&
Routing::routers() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Routing.routers)
  return routers_;
}

// .trafficcontrol.FailoverConfig failover = 11;
inline bool Routing::_internal_has_failover() const {
  return this != internal_default_instance() && failover_ != nullptr;
}
inline bool Routing::has_failover() const {
  return _internal_has_failover();
}
inline void Routing::clear_failover() {
  if (GetArenaForAllocation() == nullptr && failover_ != nullptr) {
    delete failover_;
  }
  failover_ = nullptr;
}
inline const ::trafficcontrol::FailoverConfig& Routing::_internal_failover() const {
  const ::trafficcontrol::FailoverConfig* p = failover_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::FailoverConfig&>(
      ::trafficcontrol::_FailoverConfig_default_instance_);
}
inline const ::trafficcontrol::FailoverConfig& Routing::failover() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Routing.failover)
  return _internal_failover();
}
inline void Routing::unsafe_arena_set_allocated_failover(
    ::trafficcontrol::FailoverConfig* failover) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(failover_);
  }
  failover_ = failover;
  if (failover) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Routing.failover)
}
inline ::trafficcontrol::FailoverConfig* Routing::release_failover() {
  
  ::trafficcontrol::FailoverConfig* temp = failover_;
  failover_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::FailoverConfig* Routing::unsafe_arena_release_failover() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Routing.failover)
  
  ::trafficcontrol::FailoverConfig* temp = failover_;
  failover_ = nullptr;
  return temp;
}
inline ::trafficcontrol::FailoverConfig* Routing::_internal_mutable_failover() {
  
  if (failover_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::FailoverConfig>(GetArenaForAllocation());
    failover_ = p;
  }
  return failover_;
}
inline ::trafficcontrol::FailoverConfig* Routing::mutable_failover() {
  ::trafficcontrol::FailoverConfig* _msg = _internal_mutable_failover();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Routing.failover)
  return _msg;
}
inline void Routing::set_allocated_failover(::trafficcontrol::FailoverConfig* failover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete failover_;
  }
  if (failover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(failover);
    if (message_arena != submessage_arena) {
      failover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, failover, submessage_arena);
    }
    
  } else {
    
  }
  failover_ = failover;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Routing.failover)
}

// -------------------------------------------------------------------

// Router

// .google.protobuf.BoolValue enable = 1;
inline bool Router::_internal_has_enable() const {
  return this != internal_default_instance() && enable_ != nullptr;
}
inline bool Router::has_enable() const {
  return _internal_has_enable();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Router::_internal_enable() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = enable_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Router::enable() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Router.enable)
  return _internal_enable();
}
inline void Router::unsafe_arena_set_allocated_enable(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  enable_ = enable;
  if (enable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Router.enable)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Router::release_enable() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Router::unsafe_arena_release_enable() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Router.enable)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Router::_internal_mutable_enable() {
  
  if (enable_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    enable_ = p;
  }
  return enable_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Router::mutable_enable() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_enable();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Router.enable)
  return _msg;
}
inline void Router::set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  if (enable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable));
    if (message_arena != submessage_arena) {
      enable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enable, submessage_arena);
    }
    
  } else {
    
  }
  enable_ = enable;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Router.enable)
}

// .trafficcontrol.RoutingPolicy routing_policy = 2;
inline void Router::clear_routing_policy() {
  routing_policy_ = 0;
}
inline ::trafficcontrol::RoutingPolicy Router::_internal_routing_policy() const {
  return static_cast< ::trafficcontrol::RoutingPolicy >(routing_policy_);
}
inline ::trafficcontrol::RoutingPolicy Router::routing_policy() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Router.routing_policy)
  return _internal_routing_policy();
}
inline void Router::_internal_set_routing_policy(::trafficcontrol::RoutingPolicy value) {
  
  routing_policy_ = value;
}
inline void Router::set_routing_policy(::trafficcontrol::RoutingPolicy value) {
  _internal_set_routing_policy(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.Router.routing_policy)
}

// .google.protobuf.Any routing_config = 3;
inline bool Router::_internal_has_routing_config() const {
  return this != internal_default_instance() && routing_config_ != nullptr;
}
inline bool Router::has_routing_config() const {
  return _internal_has_routing_config();
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Router::_internal_routing_config() const {
  const ::PROTOBUF_NAMESPACE_ID::Any* p = routing_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Any&>(
      ::PROTOBUF_NAMESPACE_ID::_Any_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::Any& Router::routing_config() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Router.routing_config)
  return _internal_routing_config();
}
inline void Router::unsafe_arena_set_allocated_routing_config(
    ::PROTOBUF_NAMESPACE_ID::Any* routing_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_config_);
  }
  routing_config_ = routing_config;
  if (routing_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Router.routing_config)
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::release_routing_config() {
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = routing_config_;
  routing_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::unsafe_arena_release_routing_config() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Router.routing_config)
  
  ::PROTOBUF_NAMESPACE_ID::Any* temp = routing_config_;
  routing_config_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::_internal_mutable_routing_config() {
  
  if (routing_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::Any>(GetArenaForAllocation());
    routing_config_ = p;
  }
  return routing_config_;
}
inline ::PROTOBUF_NAMESPACE_ID::Any* Router::mutable_routing_config() {
  ::PROTOBUF_NAMESPACE_ID::Any* _msg = _internal_mutable_routing_config();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Router.routing_config)
  return _msg;
}
inline void Router::set_allocated_routing_config(::PROTOBUF_NAMESPACE_ID::Any* routing_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_config_);
  }
  if (routing_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(routing_config));
    if (message_arena != submessage_arena) {
      routing_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, routing_config, submessage_arena);
    }
    
  } else {
    
  }
  routing_config_ = routing_config;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Router.routing_config)
}

// -------------------------------------------------------------------

// MatchString

// .trafficcontrol.MatchString.MatchStringType type = 1;
inline void MatchString::clear_type() {
  type_ = 0;
}
inline ::trafficcontrol::MatchString_MatchStringType MatchString::_internal_type() const {
  return static_cast< ::trafficcontrol::MatchString_MatchStringType >(type_);
}
inline ::trafficcontrol::MatchString_MatchStringType MatchString::type() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.type)
  return _internal_type();
}
inline void MatchString::_internal_set_type(::trafficcontrol::MatchString_MatchStringType value) {
  
  type_ = value;
}
inline void MatchString::set_type(::trafficcontrol::MatchString_MatchStringType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MatchString.type)
}

// .google.protobuf.StringValue value = 2;
inline bool MatchString::_internal_has_value() const {
  return this != internal_default_instance() && value_ != nullptr;
}
inline bool MatchString::has_value() const {
  return _internal_has_value();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MatchString::_internal_value() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = value_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& MatchString::value() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.value)
  return _internal_value();
}
inline void MatchString::unsafe_arena_set_allocated_value(
    ::PROTOBUF_NAMESPACE_ID::StringValue* value) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  value_ = value;
  if (value) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.MatchString.value)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::release_value() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::unsafe_arena_release_value() {
  // @@protoc_insertion_point(field_release:trafficcontrol.MatchString.value)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = value_;
  value_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::_internal_mutable_value() {
  
  if (value_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    value_ = p;
  }
  return value_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* MatchString::mutable_value() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.MatchString.value)
  return _msg;
}
inline void MatchString::set_allocated_value(::PROTOBUF_NAMESPACE_ID::StringValue* value) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(value_);
  }
  if (value) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(value));
    if (message_arena != submessage_arena) {
      value = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.MatchString.value)
}

// .trafficcontrol.MatchString.ValueType value_type = 3;
inline void MatchString::clear_value_type() {
  value_type_ = 0;
}
inline ::trafficcontrol::MatchString_ValueType MatchString::_internal_value_type() const {
  return static_cast< ::trafficcontrol::MatchString_ValueType >(value_type_);
}
inline ::trafficcontrol::MatchString_ValueType MatchString::value_type() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MatchString.value_type)
  return _internal_value_type();
}
inline void MatchString::_internal_set_value_type(::trafficcontrol::MatchString_ValueType value) {
  
  value_type_ = value;
}
inline void MatchString::set_value_type(::trafficcontrol::MatchString_ValueType value) {
  _internal_set_value_type(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MatchString.value_type)
}

// -------------------------------------------------------------------

// Locality

// .trafficcontrol.MatchString region = 1;
inline bool Locality::_internal_has_region() const {
  return this != internal_default_instance() && region_ != nullptr;
}
inline bool Locality::has_region() const {
  return _internal_has_region();
}
inline void Locality::clear_region() {
  if (GetArenaForAllocation() == nullptr && region_ != nullptr) {
    delete region_;
  }
  region_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_region() const {
  const ::trafficcontrol::MatchString* p = region_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::region() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.region)
  return _internal_region();
}
inline void Locality::unsafe_arena_set_allocated_region(
    ::trafficcontrol::MatchString* region) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(region_);
  }
  region_ = region;
  if (region) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.region)
}
inline ::trafficcontrol::MatchString* Locality::release_region() {
  
  ::trafficcontrol::MatchString* temp = region_;
  region_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_region() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.region)
  
  ::trafficcontrol::MatchString* temp = region_;
  region_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_region() {
  
  if (region_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    region_ = p;
  }
  return region_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_region() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.region)
  return _msg;
}
inline void Locality::set_allocated_region(::trafficcontrol::MatchString* region) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete region_;
  }
  if (region) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(region);
    if (message_arena != submessage_arena) {
      region = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    
  } else {
    
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.region)
}

// .trafficcontrol.MatchString zone = 2;
inline bool Locality::_internal_has_zone() const {
  return this != internal_default_instance() && zone_ != nullptr;
}
inline bool Locality::has_zone() const {
  return _internal_has_zone();
}
inline void Locality::clear_zone() {
  if (GetArenaForAllocation() == nullptr && zone_ != nullptr) {
    delete zone_;
  }
  zone_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_zone() const {
  const ::trafficcontrol::MatchString* p = zone_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::zone() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.zone)
  return _internal_zone();
}
inline void Locality::unsafe_arena_set_allocated_zone(
    ::trafficcontrol::MatchString* zone) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(zone_);
  }
  zone_ = zone;
  if (zone) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.zone)
}
inline ::trafficcontrol::MatchString* Locality::release_zone() {
  
  ::trafficcontrol::MatchString* temp = zone_;
  zone_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_zone() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.zone)
  
  ::trafficcontrol::MatchString* temp = zone_;
  zone_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_zone() {
  
  if (zone_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    zone_ = p;
  }
  return zone_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_zone() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_zone();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.zone)
  return _msg;
}
inline void Locality::set_allocated_zone(::trafficcontrol::MatchString* zone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete zone_;
  }
  if (zone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(zone);
    if (message_arena != submessage_arena) {
      zone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, zone, submessage_arena);
    }
    
  } else {
    
  }
  zone_ = zone;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.zone)
}

// .trafficcontrol.MatchString campus = 3;
inline bool Locality::_internal_has_campus() const {
  return this != internal_default_instance() && campus_ != nullptr;
}
inline bool Locality::has_campus() const {
  return _internal_has_campus();
}
inline void Locality::clear_campus() {
  if (GetArenaForAllocation() == nullptr && campus_ != nullptr) {
    delete campus_;
  }
  campus_ = nullptr;
}
inline const ::trafficcontrol::MatchString& Locality::_internal_campus() const {
  const ::trafficcontrol::MatchString* p = campus_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::MatchString&>(
      ::trafficcontrol::_MatchString_default_instance_);
}
inline const ::trafficcontrol::MatchString& Locality::campus() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Locality.campus)
  return _internal_campus();
}
inline void Locality::unsafe_arena_set_allocated_campus(
    ::trafficcontrol::MatchString* campus) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(campus_);
  }
  campus_ = campus;
  if (campus) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Locality.campus)
}
inline ::trafficcontrol::MatchString* Locality::release_campus() {
  
  ::trafficcontrol::MatchString* temp = campus_;
  campus_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::unsafe_arena_release_campus() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Locality.campus)
  
  ::trafficcontrol::MatchString* temp = campus_;
  campus_ = nullptr;
  return temp;
}
inline ::trafficcontrol::MatchString* Locality::_internal_mutable_campus() {
  
  if (campus_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::MatchString>(GetArenaForAllocation());
    campus_ = p;
  }
  return campus_;
}
inline ::trafficcontrol::MatchString* Locality::mutable_campus() {
  ::trafficcontrol::MatchString* _msg = _internal_mutable_campus();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Locality.campus)
  return _msg;
}
inline void Locality::set_allocated_campus(::trafficcontrol::MatchString* campus) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete campus_;
  }
  if (campus) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(campus);
    if (message_arena != submessage_arena) {
      campus = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, campus, submessage_arena);
    }
    
  } else {
    
  }
  campus_ = campus;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Locality.campus)
}

// -------------------------------------------------------------------

// FailoverConfig

// .google.protobuf.BoolValue enable = 1;
inline bool FailoverConfig::_internal_has_enable() const {
  return this != internal_default_instance() && enable_ != nullptr;
}
inline bool FailoverConfig::has_enable() const {
  return _internal_has_enable();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& FailoverConfig::_internal_enable() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = enable_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& FailoverConfig::enable() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.FailoverConfig.enable)
  return _internal_enable();
}
inline void FailoverConfig::unsafe_arena_set_allocated_enable(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  enable_ = enable;
  if (enable) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.FailoverConfig.enable)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FailoverConfig::release_enable() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FailoverConfig::unsafe_arena_release_enable() {
  // @@protoc_insertion_point(field_release:trafficcontrol.FailoverConfig.enable)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = enable_;
  enable_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FailoverConfig::_internal_mutable_enable() {
  
  if (enable_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    enable_ = p;
  }
  return enable_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* FailoverConfig::mutable_enable() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_enable();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.FailoverConfig.enable)
  return _msg;
}
inline void FailoverConfig::set_allocated_enable(::PROTOBUF_NAMESPACE_ID::BoolValue* enable) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable_);
  }
  if (enable) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(enable));
    if (message_arena != submessage_arena) {
      enable = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, enable, submessage_arena);
    }
    
  } else {
    
  }
  enable_ = enable;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.FailoverConfig.enable)
}

// .google.protobuf.UInt32Value total_count = 2;
inline bool FailoverConfig::_internal_has_total_count() const {
  return this != internal_default_instance() && total_count_ != nullptr;
}
inline bool FailoverConfig::has_total_count() const {
  return _internal_has_total_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::_internal_total_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = total_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::total_count() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.FailoverConfig.total_count)
  return _internal_total_count();
}
inline void FailoverConfig::unsafe_arena_set_allocated_total_count(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count_);
  }
  total_count_ = total_count;
  if (total_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.FailoverConfig.total_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::release_total_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = total_count_;
  total_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::unsafe_arena_release_total_count() {
  // @@protoc_insertion_point(field_release:trafficcontrol.FailoverConfig.total_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = total_count_;
  total_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::_internal_mutable_total_count() {
  
  if (total_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    total_count_ = p;
  }
  return total_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::mutable_total_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_total_count();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.FailoverConfig.total_count)
  return _msg;
}
inline void FailoverConfig::set_allocated_total_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* total_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count_);
  }
  if (total_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(total_count));
    if (message_arena != submessage_arena) {
      total_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, total_count, submessage_arena);
    }
    
  } else {
    
  }
  total_count_ = total_count;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.FailoverConfig.total_count)
}

// .google.protobuf.UInt32Value healthy_count = 3;
inline bool FailoverConfig::_internal_has_healthy_count() const {
  return this != internal_default_instance() && healthy_count_ != nullptr;
}
inline bool FailoverConfig::has_healthy_count() const {
  return _internal_has_healthy_count();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::_internal_healthy_count() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = healthy_count_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::healthy_count() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.FailoverConfig.healthy_count)
  return _internal_healthy_count();
}
inline void FailoverConfig::unsafe_arena_set_allocated_healthy_count(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count_);
  }
  healthy_count_ = healthy_count;
  if (healthy_count) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.FailoverConfig.healthy_count)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::release_healthy_count() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_count_;
  healthy_count_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::unsafe_arena_release_healthy_count() {
  // @@protoc_insertion_point(field_release:trafficcontrol.FailoverConfig.healthy_count)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_count_;
  healthy_count_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::_internal_mutable_healthy_count() {
  
  if (healthy_count_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    healthy_count_ = p;
  }
  return healthy_count_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::mutable_healthy_count() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_healthy_count();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.FailoverConfig.healthy_count)
  return _msg;
}
inline void FailoverConfig::set_allocated_healthy_count(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_count) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count_);
  }
  if (healthy_count) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_count));
    if (message_arena != submessage_arena) {
      healthy_count = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, healthy_count, submessage_arena);
    }
    
  } else {
    
  }
  healthy_count_ = healthy_count;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.FailoverConfig.healthy_count)
}

// .google.protobuf.UInt32Value healthy_percent = 4;
inline bool FailoverConfig::_internal_has_healthy_percent() const {
  return this != internal_default_instance() && healthy_percent_ != nullptr;
}
inline bool FailoverConfig::has_healthy_percent() const {
  return _internal_has_healthy_percent();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::_internal_healthy_percent() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = healthy_percent_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& FailoverConfig::healthy_percent() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.FailoverConfig.healthy_percent)
  return _internal_healthy_percent();
}
inline void FailoverConfig::unsafe_arena_set_allocated_healthy_percent(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent_);
  }
  healthy_percent_ = healthy_percent;
  if (healthy_percent) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.FailoverConfig.healthy_percent)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::release_healthy_percent() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_percent_;
  healthy_percent_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::unsafe_arena_release_healthy_percent() {
  // @@protoc_insertion_point(field_release:trafficcontrol.FailoverConfig.healthy_percent)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = healthy_percent_;
  healthy_percent_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::_internal_mutable_healthy_percent() {
  
  if (healthy_percent_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    healthy_percent_ = p;
  }
  return healthy_percent_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* FailoverConfig::mutable_healthy_percent() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_healthy_percent();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.FailoverConfig.healthy_percent)
  return _msg;
}
inline void FailoverConfig::set_allocated_healthy_percent(::PROTOBUF_NAMESPACE_ID::UInt32Value* healthy_percent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent_);
  }
  if (healthy_percent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(healthy_percent));
    if (message_arena != submessage_arena) {
      healthy_percent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, healthy_percent, submessage_arena);
    }
    
  } else {
    
  }
  healthy_percent_ = healthy_percent;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.FailoverConfig.healthy_percent)
}

// -------------------------------------------------------------------

// RuleRoutingConfig

// repeated .trafficcontrol.Route inbounds = 1;
inline int RuleRoutingConfig::_internal_inbounds_size() const {
  return inbounds_.size();
}
inline int RuleRoutingConfig::inbounds_size() const {
  return _internal_inbounds_size();
}
inline void RuleRoutingConfig::clear_inbounds() {
  inbounds_.Clear();
}
inline ::trafficcontrol::Route* RuleRoutingConfig::mutable_inbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRoutingConfig.inbounds)
  return inbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
RuleRoutingConfig::mutable_inbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.RuleRoutingConfig.inbounds)
  return &inbounds_;
}
inline const ::trafficcontrol::Route& RuleRoutingConfig::_internal_inbounds(int index) const {
  return inbounds_.Get(index);
}
inline const ::trafficcontrol::Route& RuleRoutingConfig::inbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRoutingConfig.inbounds)
  return _internal_inbounds(index);
}
inline ::trafficcontrol::Route* RuleRoutingConfig::_internal_add_inbounds() {
  return inbounds_.Add();
}
inline ::trafficcontrol::Route* RuleRoutingConfig::add_inbounds() {
  ::trafficcontrol::Route* _add = _internal_add_inbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.RuleRoutingConfig.inbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
RuleRoutingConfig::inbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.RuleRoutingConfig.inbounds)
  return inbounds_;
}

// repeated .trafficcontrol.Route outbounds = 2;
inline int RuleRoutingConfig::_internal_outbounds_size() const {
  return outbounds_.size();
}
inline int RuleRoutingConfig::outbounds_size() const {
  return _internal_outbounds_size();
}
inline void RuleRoutingConfig::clear_outbounds() {
  outbounds_.Clear();
}
inline ::trafficcontrol::Route* RuleRoutingConfig::mutable_outbounds(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.RuleRoutingConfig.outbounds)
  return outbounds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >*
RuleRoutingConfig::mutable_outbounds() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.RuleRoutingConfig.outbounds)
  return &outbounds_;
}
inline const ::trafficcontrol::Route& RuleRoutingConfig::_internal_outbounds(int index) const {
  return outbounds_.Get(index);
}
inline const ::trafficcontrol::Route& RuleRoutingConfig::outbounds(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.RuleRoutingConfig.outbounds)
  return _internal_outbounds(index);
}
inline ::trafficcontrol::Route* RuleRoutingConfig::_internal_add_outbounds() {
  return outbounds_.Add();
}
inline ::trafficcontrol::Route* RuleRoutingConfig::add_outbounds() {
  ::trafficcontrol::Route* _add = _internal_add_outbounds();
  // @@protoc_insertion_point(field_add:trafficcontrol.RuleRoutingConfig.outbounds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Route >&
RuleRoutingConfig::outbounds() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.RuleRoutingConfig.outbounds)
  return outbounds_;
}

// -------------------------------------------------------------------

// Route

// repeated .trafficcontrol.Source sources = 1;
inline int Route::_internal_sources_size() const {
  return sources_.size();
}
inline int Route::sources_size() const {
  return _internal_sources_size();
}
inline void Route::clear_sources() {
  sources_.Clear();
}
inline ::trafficcontrol::Source* Route::mutable_sources(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Route.sources)
  return sources_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >*
Route::mutable_sources() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Route.sources)
  return &sources_;
}
inline const ::trafficcontrol::Source& Route::_internal_sources(int index) const {
  return sources_.Get(index);
}
inline const ::trafficcontrol::Source& Route::sources(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Route.sources)
  return _internal_sources(index);
}
inline ::trafficcontrol::Source* Route::_internal_add_sources() {
  return sources_.Add();
}
inline ::trafficcontrol::Source* Route::add_sources() {
  ::trafficcontrol::Source* _add = _internal_add_sources();
  // @@protoc_insertion_point(field_add:trafficcontrol.Route.sources)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Source >&
Route::sources() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Route.sources)
  return sources_;
}

// repeated .trafficcontrol.Destination destinations = 2;
inline int Route::_internal_destinations_size() const {
  return destinations_.size();
}
inline int Route::destinations_size() const {
  return _internal_destinations_size();
}
inline void Route::clear_destinations() {
  destinations_.Clear();
}
inline ::trafficcontrol::Destination* Route::mutable_destinations(int index) {
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Route.destinations)
  return destinations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >*
Route::mutable_destinations() {
  // @@protoc_insertion_point(field_mutable_list:trafficcontrol.Route.destinations)
  return &destinations_;
}
inline const ::trafficcontrol::Destination& Route::_internal_destinations(int index) const {
  return destinations_.Get(index);
}
inline const ::trafficcontrol::Destination& Route::destinations(int index) const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Route.destinations)
  return _internal_destinations(index);
}
inline ::trafficcontrol::Destination* Route::_internal_add_destinations() {
  return destinations_.Add();
}
inline ::trafficcontrol::Destination* Route::add_destinations() {
  ::trafficcontrol::Destination* _add = _internal_add_destinations();
  // @@protoc_insertion_point(field_add:trafficcontrol.Route.destinations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::trafficcontrol::Destination >&
Route::destinations() const {
  // @@protoc_insertion_point(field_list:trafficcontrol.Route.destinations)
  return destinations_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Source

// .google.protobuf.StringValue service = 1;
inline bool Source::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool Source::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.service)
  return _internal_service();
}
inline void Source::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.service)
  return _msg;
}
inline void Source::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.service)
}

// .google.protobuf.StringValue namespace = 2;
inline bool Source::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Source::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Source::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.namespace)
  return _internal_namespace_();
}
inline void Source::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Source::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.namespace)
  return _msg;
}
inline void Source::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.namespace)
}

// map<string, .trafficcontrol.MatchString> metadata = 3;
inline int Source::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Source::metadata_size() const {
  return _internal_metadata_size();
}
inline void Source::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Source::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Source::metadata() const {
  // @@protoc_insertion_point(field_map:trafficcontrol.Source.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Source::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Source::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:trafficcontrol.Source.metadata)
  return _internal_mutable_metadata();
}

// .trafficcontrol.Locality locality = 4;
inline bool Source::_internal_has_locality() const {
  return this != internal_default_instance() && locality_ != nullptr;
}
inline bool Source::has_locality() const {
  return _internal_has_locality();
}
inline void Source::clear_locality() {
  if (GetArenaForAllocation() == nullptr && locality_ != nullptr) {
    delete locality_;
  }
  locality_ = nullptr;
}
inline const ::trafficcontrol::Locality& Source::_internal_locality() const {
  const ::trafficcontrol::Locality* p = locality_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::Locality&>(
      ::trafficcontrol::_Locality_default_instance_);
}
inline const ::trafficcontrol::Locality& Source::locality() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Source.locality)
  return _internal_locality();
}
inline void Source::unsafe_arena_set_allocated_locality(
    ::trafficcontrol::Locality* locality) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locality_);
  }
  locality_ = locality;
  if (locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Source.locality)
}
inline ::trafficcontrol::Locality* Source::release_locality() {
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::Locality* Source::unsafe_arena_release_locality() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Source.locality)
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
  return temp;
}
inline ::trafficcontrol::Locality* Source::_internal_mutable_locality() {
  
  if (locality_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::Locality>(GetArenaForAllocation());
    locality_ = p;
  }
  return locality_;
}
inline ::trafficcontrol::Locality* Source::mutable_locality() {
  ::trafficcontrol::Locality* _msg = _internal_mutable_locality();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Source.locality)
  return _msg;
}
inline void Source::set_allocated_locality(::trafficcontrol::Locality* locality) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete locality_;
  }
  if (locality) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locality);
    if (message_arena != submessage_arena) {
      locality = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locality, submessage_arena);
    }
    
  } else {
    
  }
  locality_ = locality;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Source.locality)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Destination

// .google.protobuf.StringValue service = 1;
inline bool Destination::_internal_has_service() const {
  return this != internal_default_instance() && service_ != nullptr;
}
inline bool Destination::has_service() const {
  return _internal_has_service();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_service() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = service_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::service() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.service)
  return _internal_service();
}
inline void Destination::unsafe_arena_set_allocated_service(
    ::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  service_ = service;
  if (service) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.service)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_service() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.service)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = service_;
  service_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_service() {
  
  if (service_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    service_ = p;
  }
  return service_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_service() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_service();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.service)
  return _msg;
}
inline void Destination::set_allocated_service(::PROTOBUF_NAMESPACE_ID::StringValue* service) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(service_);
  }
  if (service) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(service));
    if (message_arena != submessage_arena) {
      service = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, service, submessage_arena);
    }
    
  } else {
    
  }
  service_ = service;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.service)
}

// .google.protobuf.StringValue namespace = 2;
inline bool Destination::_internal_has_namespace_() const {
  return this != internal_default_instance() && namespace__ != nullptr;
}
inline bool Destination::has_namespace_() const {
  return _internal_has_namespace_();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_namespace_() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = namespace__;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::namespace_() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.namespace)
  return _internal_namespace_();
}
inline void Destination::unsafe_arena_set_allocated_namespace_(
    ::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  namespace__ = namespace_;
  if (namespace_) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.namespace)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_namespace_() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_namespace_() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.namespace)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = namespace__;
  namespace__ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_namespace_() {
  
  if (namespace__ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    namespace__ = p;
  }
  return namespace__;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_namespace_() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_namespace_();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.namespace)
  return _msg;
}
inline void Destination::set_allocated_namespace_(::PROTOBUF_NAMESPACE_ID::StringValue* namespace_) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace__);
  }
  if (namespace_) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(namespace_));
    if (message_arena != submessage_arena) {
      namespace_ = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, namespace_, submessage_arena);
    }
    
  } else {
    
  }
  namespace__ = namespace_;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.namespace)
}

// map<string, .trafficcontrol.MatchString> metadata = 3;
inline int Destination::_internal_metadata_size() const {
  return metadata_.size();
}
inline int Destination::metadata_size() const {
  return _internal_metadata_size();
}
inline void Destination::clear_metadata() {
  metadata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Destination::_internal_metadata() const {
  return metadata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >&
Destination::metadata() const {
  // @@protoc_insertion_point(field_map:trafficcontrol.Destination.metadata)
  return _internal_metadata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Destination::_internal_mutable_metadata() {
  return metadata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::trafficcontrol::MatchString >*
Destination::mutable_metadata() {
  // @@protoc_insertion_point(field_mutable_map:trafficcontrol.Destination.metadata)
  return _internal_mutable_metadata();
}

// .google.protobuf.UInt32Value priority = 4;
inline bool Destination::_internal_has_priority() const {
  return this != internal_default_instance() && priority_ != nullptr;
}
inline bool Destination::has_priority() const {
  return _internal_has_priority();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::_internal_priority() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = priority_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::priority() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.priority)
  return _internal_priority();
}
inline void Destination::unsafe_arena_set_allocated_priority(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* priority) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority_);
  }
  priority_ = priority;
  if (priority) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.priority)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::release_priority() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = priority_;
  priority_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::unsafe_arena_release_priority() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.priority)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = priority_;
  priority_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::_internal_mutable_priority() {
  
  if (priority_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    priority_ = p;
  }
  return priority_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::mutable_priority() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_priority();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.priority)
  return _msg;
}
inline void Destination::set_allocated_priority(::PROTOBUF_NAMESPACE_ID::UInt32Value* priority) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority_);
  }
  if (priority) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(priority));
    if (message_arena != submessage_arena) {
      priority = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, priority, submessage_arena);
    }
    
  } else {
    
  }
  priority_ = priority;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.priority)
}

// .google.protobuf.UInt32Value weight = 5;
inline bool Destination::_internal_has_weight() const {
  return this != internal_default_instance() && weight_ != nullptr;
}
inline bool Destination::has_weight() const {
  return _internal_has_weight();
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::_internal_weight() const {
  const ::PROTOBUF_NAMESPACE_ID::UInt32Value* p = weight_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::UInt32Value&>(
      ::PROTOBUF_NAMESPACE_ID::_UInt32Value_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::UInt32Value& Destination::weight() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.weight)
  return _internal_weight();
}
inline void Destination::unsafe_arena_set_allocated_weight(
    ::PROTOBUF_NAMESPACE_ID::UInt32Value* weight) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight_);
  }
  weight_ = weight;
  if (weight) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.weight)
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::release_weight() {
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = weight_;
  weight_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::unsafe_arena_release_weight() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.weight)
  
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* temp = weight_;
  weight_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::_internal_mutable_weight() {
  
  if (weight_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::UInt32Value>(GetArenaForAllocation());
    weight_ = p;
  }
  return weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::UInt32Value* Destination::mutable_weight() {
  ::PROTOBUF_NAMESPACE_ID::UInt32Value* _msg = _internal_mutable_weight();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.weight)
  return _msg;
}
inline void Destination::set_allocated_weight(::PROTOBUF_NAMESPACE_ID::UInt32Value* weight) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight_);
  }
  if (weight) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(weight));
    if (message_arena != submessage_arena) {
      weight = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, weight, submessage_arena);
    }
    
  } else {
    
  }
  weight_ = weight;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.weight)
}

// .google.protobuf.StringValue transfer = 6;
inline bool Destination::_internal_has_transfer() const {
  return this != internal_default_instance() && transfer_ != nullptr;
}
inline bool Destination::has_transfer() const {
  return _internal_has_transfer();
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::_internal_transfer() const {
  const ::PROTOBUF_NAMESPACE_ID::StringValue* p = transfer_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::StringValue&>(
      ::PROTOBUF_NAMESPACE_ID::_StringValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::StringValue& Destination::transfer() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.transfer)
  return _internal_transfer();
}
inline void Destination::unsafe_arena_set_allocated_transfer(
    ::PROTOBUF_NAMESPACE_ID::StringValue* transfer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_);
  }
  transfer_ = transfer;
  if (transfer) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.transfer)
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::release_transfer() {
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = transfer_;
  transfer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::unsafe_arena_release_transfer() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.transfer)
  
  ::PROTOBUF_NAMESPACE_ID::StringValue* temp = transfer_;
  transfer_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::_internal_mutable_transfer() {
  
  if (transfer_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::StringValue>(GetArenaForAllocation());
    transfer_ = p;
  }
  return transfer_;
}
inline ::PROTOBUF_NAMESPACE_ID::StringValue* Destination::mutable_transfer() {
  ::PROTOBUF_NAMESPACE_ID::StringValue* _msg = _internal_mutable_transfer();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.transfer)
  return _msg;
}
inline void Destination::set_allocated_transfer(::PROTOBUF_NAMESPACE_ID::StringValue* transfer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer_);
  }
  if (transfer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transfer));
    if (message_arena != submessage_arena) {
      transfer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transfer, submessage_arena);
    }
    
  } else {
    
  }
  transfer_ = transfer;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.transfer)
}

// .google.protobuf.BoolValue isolate = 7;
inline bool Destination::_internal_has_isolate() const {
  return this != internal_default_instance() && isolate_ != nullptr;
}
inline bool Destination::has_isolate() const {
  return _internal_has_isolate();
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Destination::_internal_isolate() const {
  const ::PROTOBUF_NAMESPACE_ID::BoolValue* p = isolate_;
  return p != nullptr ? *p : reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::BoolValue&>(
      ::PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const ::PROTOBUF_NAMESPACE_ID::BoolValue& Destination::isolate() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.isolate)
  return _internal_isolate();
}
inline void Destination::unsafe_arena_set_allocated_isolate(
    ::PROTOBUF_NAMESPACE_ID::BoolValue* isolate) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate_);
  }
  isolate_ = isolate;
  if (isolate) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.isolate)
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::release_isolate() {
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = isolate_;
  isolate_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::unsafe_arena_release_isolate() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.isolate)
  
  ::PROTOBUF_NAMESPACE_ID::BoolValue* temp = isolate_;
  isolate_ = nullptr;
  return temp;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::_internal_mutable_isolate() {
  
  if (isolate_ == nullptr) {
    auto* p = CreateMaybeMessage<::PROTOBUF_NAMESPACE_ID::BoolValue>(GetArenaForAllocation());
    isolate_ = p;
  }
  return isolate_;
}
inline ::PROTOBUF_NAMESPACE_ID::BoolValue* Destination::mutable_isolate() {
  ::PROTOBUF_NAMESPACE_ID::BoolValue* _msg = _internal_mutable_isolate();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.isolate)
  return _msg;
}
inline void Destination::set_allocated_isolate(::PROTOBUF_NAMESPACE_ID::BoolValue* isolate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate_);
  }
  if (isolate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(isolate));
    if (message_arena != submessage_arena) {
      isolate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, isolate, submessage_arena);
    }
    
  } else {
    
  }
  isolate_ = isolate;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.isolate)
}

// .trafficcontrol.Locality locality = 8;
inline bool Destination::_internal_has_locality() const {
  return this != internal_default_instance() && locality_ != nullptr;
}
inline bool Destination::has_locality() const {
  return _internal_has_locality();
}
inline void Destination::clear_locality() {
  if (GetArenaForAllocation() == nullptr && locality_ != nullptr) {
    delete locality_;
  }
  locality_ = nullptr;
}
inline const ::trafficcontrol::Locality& Destination::_internal_locality() const {
  const ::trafficcontrol::Locality* p = locality_;
  return p != nullptr ? *p : reinterpret_cast<const ::trafficcontrol::Locality&>(
      ::trafficcontrol::_Locality_default_instance_);
}
inline const ::trafficcontrol::Locality& Destination::locality() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.Destination.locality)
  return _internal_locality();
}
inline void Destination::unsafe_arena_set_allocated_locality(
    ::trafficcontrol::Locality* locality) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(locality_);
  }
  locality_ = locality;
  if (locality) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:trafficcontrol.Destination.locality)
}
inline ::trafficcontrol::Locality* Destination::release_locality() {
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::trafficcontrol::Locality* Destination::unsafe_arena_release_locality() {
  // @@protoc_insertion_point(field_release:trafficcontrol.Destination.locality)
  
  ::trafficcontrol::Locality* temp = locality_;
  locality_ = nullptr;
  return temp;
}
inline ::trafficcontrol::Locality* Destination::_internal_mutable_locality() {
  
  if (locality_ == nullptr) {
    auto* p = CreateMaybeMessage<::trafficcontrol::Locality>(GetArenaForAllocation());
    locality_ = p;
  }
  return locality_;
}
inline ::trafficcontrol::Locality* Destination::mutable_locality() {
  ::trafficcontrol::Locality* _msg = _internal_mutable_locality();
  // @@protoc_insertion_point(field_mutable:trafficcontrol.Destination.locality)
  return _msg;
}
inline void Destination::set_allocated_locality(::trafficcontrol::Locality* locality) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete locality_;
  }
  if (locality) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(locality);
    if (message_arena != submessage_arena) {
      locality = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, locality, submessage_arena);
    }
    
  } else {
    
  }
  locality_ = locality;
  // @@protoc_insertion_point(field_set_allocated:trafficcontrol.Destination.locality)
}

// -------------------------------------------------------------------

// LocalityRoutingConfig

// .trafficcontrol.LocalityRoutingConfig.LocalityLevel locality_level = 1;
inline void LocalityRoutingConfig::clear_locality_level() {
  locality_level_ = 0;
}
inline ::trafficcontrol::LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig::_internal_locality_level() const {
  return static_cast< ::trafficcontrol::LocalityRoutingConfig_LocalityLevel >(locality_level_);
}
inline ::trafficcontrol::LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig::locality_level() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.LocalityRoutingConfig.locality_level)
  return _internal_locality_level();
}
inline void LocalityRoutingConfig::_internal_set_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value) {
  
  locality_level_ = value;
}
inline void LocalityRoutingConfig::set_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value) {
  _internal_set_locality_level(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.LocalityRoutingConfig.locality_level)
}

// .trafficcontrol.LocalityRoutingConfig.LocalityLevel max_locality_level = 2;
inline void LocalityRoutingConfig::clear_max_locality_level() {
  max_locality_level_ = 0;
}
inline ::trafficcontrol::LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig::_internal_max_locality_level() const {
  return static_cast< ::trafficcontrol::LocalityRoutingConfig_LocalityLevel >(max_locality_level_);
}
inline ::trafficcontrol::LocalityRoutingConfig_LocalityLevel LocalityRoutingConfig::max_locality_level() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.LocalityRoutingConfig.max_locality_level)
  return _internal_max_locality_level();
}
inline void LocalityRoutingConfig::_internal_set_max_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value) {
  
  max_locality_level_ = value;
}
inline void LocalityRoutingConfig::set_max_locality_level(::trafficcontrol::LocalityRoutingConfig_LocalityLevel value) {
  _internal_set_max_locality_level(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.LocalityRoutingConfig.max_locality_level)
}

// -------------------------------------------------------------------

// MetadataRoutingConfig

// .trafficcontrol.MetadataRoutingConfig.FailoverRange failover_range = 1;
inline void MetadataRoutingConfig::clear_failover_range() {
  failover_range_ = 0;
}
inline ::trafficcontrol::MetadataRoutingConfig_FailoverRange MetadataRoutingConfig::_internal_failover_range() const {
  return static_cast< ::trafficcontrol::MetadataRoutingConfig_FailoverRange >(failover_range_);
}
inline ::trafficcontrol::MetadataRoutingConfig_FailoverRange MetadataRoutingConfig::failover_range() const {
  // @@protoc_insertion_point(field_get:trafficcontrol.MetadataRoutingConfig.failover_range)
  return _internal_failover_range();
}
inline void MetadataRoutingConfig::_internal_set_failover_range(::trafficcontrol::MetadataRoutingConfig_FailoverRange value) {
  
  failover_range_ = value;
}
inline void MetadataRoutingConfig::set_failover_range(::trafficcontrol::MetadataRoutingConfig_FailoverRange value) {
  _internal_set_failover_range(value);
  // @@protoc_insertion_point(field_set:trafficcontrol.MetadataRoutingConfig.failover_range)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace trafficcontrol

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::trafficcontrol::MatchString_MatchStringType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MatchString_MatchStringType>() {
  return ::trafficcontrol::MatchString_MatchStringType_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::MatchString_ValueType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MatchString_ValueType>() {
  return ::trafficcontrol::MatchString_ValueType_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::LocalityRoutingConfig_LocalityLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::LocalityRoutingConfig_LocalityLevel>() {
  return ::trafficcontrol::LocalityRoutingConfig_LocalityLevel_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::MetadataRoutingConfig_FailoverRange> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::MetadataRoutingConfig_FailoverRange>() {
  return ::trafficcontrol::MetadataRoutingConfig_FailoverRange_descriptor();
}
template <> struct is_proto_enum< ::trafficcontrol::RoutingPolicy> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::trafficcontrol::RoutingPolicy>() {
  return ::trafficcontrol::RoutingPolicy_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_router_2eproto
